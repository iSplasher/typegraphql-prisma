// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`inputs should generate proper ScalarWhereWithAggregatesInput for model: SampleScalarWhereWithAggregatesInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { BoolWithAggregatesFilter } from \\"../inputs/BoolWithAggregatesFilter\\";
import { DateTimeWithAggregatesFilter } from \\"../inputs/DateTimeWithAggregatesFilter\\";
import { FloatWithAggregatesFilter } from \\"../inputs/FloatWithAggregatesFilter\\";
import { IntWithAggregatesFilter } from \\"../inputs/IntWithAggregatesFilter\\";
import { JsonWithAggregatesFilter } from \\"../inputs/JsonWithAggregatesFilter\\";
import { StringWithAggregatesFilter } from \\"../inputs/StringWithAggregatesFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleScalarWhereWithAggregatesInput {
  @TypeGraphQL.Field(_type => [SampleScalarWhereWithAggregatesInput], {
    nullable: true
  })
  AND?: SampleScalarWhereWithAggregatesInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleScalarWhereWithAggregatesInput], {
    nullable: true
  })
  OR?: SampleScalarWhereWithAggregatesInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleScalarWhereWithAggregatesInput], {
    nullable: true
  })
  NOT?: SampleScalarWhereWithAggregatesInput[] | undefined;

  @TypeGraphQL.Field(_type => IntWithAggregatesFilter, {
    nullable: true
  })
<<<<<<< HEAD
  not?: NestedEnumColorFilter | undefined;

  @TypeGraphQL.Field(_type => Color, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [Color], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: Array<\\"RED\\" | \\"GREEN\\" | \\"BLUE\\"> | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [Color], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: Array<\\"RED\\" | \\"GREEN\\" | \\"BLUE\\"> | undefined) {
  this.notIn = notIn;
}

    @TypeGraphQL.Field(_type => NestedEnumColorFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedEnumColorFilter | undefined) {
  this.not = not;
}
}
"
`;
=======
  idField?: IntWithAggregatesFilter | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e

  @TypeGraphQL.Field(_type => StringWithAggregatesFilter, {
    nullable: true
  })
  stringField?: StringWithAggregatesFilter | undefined;

  @TypeGraphQL.Field(_type => FloatWithAggregatesFilter, {
    nullable: true
  })
  floatField?: FloatWithAggregatesFilter | undefined;

  @TypeGraphQL.Field(_type => IntWithAggregatesFilter, {
    nullable: true
  })
  intField?: IntWithAggregatesFilter | undefined;

  @TypeGraphQL.Field(_type => BoolWithAggregatesFilter, {
    nullable: true
  })
  booleanField?: BoolWithAggregatesFilter | undefined;

  @TypeGraphQL.Field(_type => DateTimeWithAggregatesFilter, {
    nullable: true
  })
<<<<<<< HEAD
  not?: NestedEnumColorFilter | undefined;

  @TypeGraphQL.Field(_type => Color, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [Color], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: Array<\\"RED\\" | \\"GREEN\\" | \\"BLUE\\"> | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [Color], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: Array<\\"RED\\" | \\"GREEN\\" | \\"BLUE\\"> | undefined) {
  this.notIn = notIn;
}

    @TypeGraphQL.Field(_type => NestedEnumColorFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedEnumColorFilter | undefined) {
  this.not = not;
}
}
"
`;
=======
  dateField?: DateTimeWithAggregatesFilter | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e

  @TypeGraphQL.Field(_type => JsonWithAggregatesFilter, {
    nullable: true
  })
  jsonField?: JsonWithAggregatesFilter | undefined;
}
"
`;

exports[`inputs should generate proper WithAggregatesFilter for scalars: BoolWithAggregatesFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedBoolFilter } from \\"../inputs/NestedBoolFilter\\";
import { NestedBoolWithAggregatesFilter } from \\"../inputs/NestedBoolWithAggregatesFilter\\";
import { NestedIntFilter } from \\"../inputs/NestedIntFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class BoolWithAggregatesFilter {
  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  equals?: boolean | undefined;

  @TypeGraphQL.Field(_type => NestedBoolWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedBoolWithAggregatesFilter | undefined;

  @TypeGraphQL.Field(_type => NestedIntFilter, {
    nullable: true
  })
<<<<<<< HEAD
  connect?: UserWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => UserCreateWithoutPostsFieldInput, {
    nullable: true
  })
  get create() {
    return this.create;
  }

  set create(create: UserCreateWithoutPostsFieldInput | undefined) {
    this.create = create;
  }

  @TypeGraphQL.Field(_type => UserCreateOrConnectWithoutPostsFieldInput, {
    nullable: true
  })
  get connectOrCreate() {
    return this.connectOrCreate;
  }

  set connectOrCreate(connectOrCreate: UserCreateOrConnectWithoutPostsFieldInput | undefined) {
    this.connectOrCreate = connectOrCreate;
  }

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: true
  })
  get connect() {
    return this.connect;
  }

  set connect(connect: UserWhereUniqueInput | undefined) {
    this.connect = connect;
  }
=======
  _count?: NestedIntFilter | undefined;

  @TypeGraphQL.Field(_type => NestedBoolFilter, {
    nullable: true
  })
  _min?: NestedBoolFilter | undefined;

  @TypeGraphQL.Field(_type => NestedBoolFilter, {
    nullable: true
  })
  _max?: NestedBoolFilter | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs should generate proper WithAggregatesFilter for scalars: DateTimeWithAggregatesFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedDateTimeFilter } from \\"../inputs/NestedDateTimeFilter\\";
import { NestedDateTimeWithAggregatesFilter } from \\"../inputs/NestedDateTimeWithAggregatesFilter\\";
import { NestedIntFilter } from \\"../inputs/NestedIntFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class DateTimeWithAggregatesFilter {
  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  equals?: Date | undefined;

  @TypeGraphQL.Field(_type => [Date], {
    nullable: true
  })
<<<<<<< HEAD
  create!: UserCreateWithoutPostsFieldInput;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: false
  })
  get where() {
    return this.where;
  }

  set where(where: UserWhereUniqueInput) {
    this.where = where;
  }

  @TypeGraphQL.Field(_type => UserCreateWithoutPostsFieldInput, {
    nullable: false
  })
  get create() {
    return this.create;
  }

  set create(create: UserCreateWithoutPostsFieldInput) {
    this.create = create;
  }
}
"
`;
=======
  in?: Date[] | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e

  @TypeGraphQL.Field(_type => [Date], {
    nullable: true
  })
  notIn?: Date[] | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  lt?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  lte?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  gt?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  gte?: Date | undefined;

  @TypeGraphQL.Field(_type => NestedDateTimeWithAggregatesFilter, {
    nullable: true
  })
<<<<<<< HEAD
  update?: UserUpdateWithoutPostsFieldInput | undefined;

  @TypeGraphQL.Field(_type => UserCreateWithoutPostsFieldInput, {
    nullable: true
  })
  get create() {
    return this.create;
  }

  set create(create: UserCreateWithoutPostsFieldInput | undefined) {
    this.create = create;
  }

  @TypeGraphQL.Field(_type => UserCreateOrConnectWithoutPostsFieldInput, {
    nullable: true
  })
  get connectOrCreate() {
    return this.connectOrCreate;
  }

  set connectOrCreate(connectOrCreate: UserCreateOrConnectWithoutPostsFieldInput | undefined) {
    this.connectOrCreate = connectOrCreate;
  }

  @TypeGraphQL.Field(_type => UserUpsertWithoutPostsFieldInput, {
    nullable: true
  })
  get upsert() {
    return this.upsert;
  }

  set upsert(upsert: UserUpsertWithoutPostsFieldInput | undefined) {
    this.upsert = upsert;
  }

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: true
  })
  get connect() {
    return this.connect;
  }

  set connect(connect: UserWhereUniqueInput | undefined) {
    this.connect = connect;
  }

  @TypeGraphQL.Field(_type => UserUpdateWithoutPostsFieldInput, {
    nullable: true
  })
  get update() {
    return this.update;
  }

  set update(update: UserUpdateWithoutPostsFieldInput | undefined) {
    this.update = update;
  }
=======
  not?: NestedDateTimeWithAggregatesFilter | undefined;

  @TypeGraphQL.Field(_type => NestedIntFilter, {
    nullable: true
  })
  _count?: NestedIntFilter | undefined;

  @TypeGraphQL.Field(_type => NestedDateTimeFilter, {
    nullable: true
  })
  _min?: NestedDateTimeFilter | undefined;

  @TypeGraphQL.Field(_type => NestedDateTimeFilter, {
    nullable: true
  })
  _max?: NestedDateTimeFilter | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs should generate proper WithAggregatesFilter for scalars: FloatWithAggregatesFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedFloatFilter } from \\"../inputs/NestedFloatFilter\\";
import { NestedFloatWithAggregatesFilter } from \\"../inputs/NestedFloatWithAggregatesFilter\\";
import { NestedIntFilter } from \\"../inputs/NestedIntFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FloatWithAggregatesFilter {
  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  equals?: number | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Float], {
    nullable: true
  })
  in?: number[] | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Float], {
    nullable: true
  })
  notIn?: number[] | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  lt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  lte?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  gt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  gte?: number | undefined;

  @TypeGraphQL.Field(_type => NestedFloatWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedFloatWithAggregatesFilter | undefined;

  @TypeGraphQL.Field(_type => NestedIntFilter, {
    nullable: true
  })
  _count?: NestedIntFilter | undefined;

  @TypeGraphQL.Field(_type => NestedFloatFilter, {
    nullable: true
  })
  _avg?: NestedFloatFilter | undefined;

  @TypeGraphQL.Field(_type => NestedFloatFilter, {
    nullable: true
  })
<<<<<<< HEAD
  jsonField?: JsonFilter | undefined;

  @TypeGraphQL.Field(_type => [SampleModelWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: SampleModelWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [SampleModelWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: SampleModelWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [SampleModelWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: SampleModelWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get intIdField() {
    return this.intIdField;
  }

  set intIdField(intIdField: IntFilter | undefined) {
    this.intIdField = intIdField;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get stringField() {
    return this.stringField;
  }

  set stringField(stringField: StringFilter | undefined) {
    this.stringField = stringField;
  }

  @TypeGraphQL.Field(_type => StringNullableFilter, {
    nullable: true
  })
  get optionalStringField() {
    return this.optionalStringField;
  }

  set optionalStringField(optionalStringField: StringNullableFilter | undefined) {
    this.optionalStringField = optionalStringField;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get intField() {
    return this.intField;
  }

  set intField(intField: IntFilter | undefined) {
    this.intField = intField;
  }

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFilter | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => BoolFilter, {
    nullable: true
  })
  get booleanField() {
    return this.booleanField;
  }

  set booleanField(booleanField: BoolFilter | undefined) {
    this.booleanField = booleanField;
  }

  @TypeGraphQL.Field(_type => DateTimeFilter, {
    nullable: true
  })
  get dateField() {
    return this.dateField;
  }

  set dateField(dateField: DateTimeFilter | undefined) {
    this.dateField = dateField;
  }

  @TypeGraphQL.Field(_type => JsonFilter, {
    nullable: true
  })
  get jsonField() {
    return this.jsonField;
  }

  set jsonField(jsonField: JsonFilter | undefined) {
    this.jsonField = jsonField;
  }
=======
  _sum?: NestedFloatFilter | undefined;

  @TypeGraphQL.Field(_type => NestedFloatFilter, {
    nullable: true
  })
  _min?: NestedFloatFilter | undefined;

  @TypeGraphQL.Field(_type => NestedFloatFilter, {
    nullable: true
  })
  _max?: NestedFloatFilter | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs should generate proper WithAggregatesFilter for scalars: IntWithAggregatesFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedFloatFilter } from \\"../inputs/NestedFloatFilter\\";
import { NestedIntFilter } from \\"../inputs/NestedIntFilter\\";
import { NestedIntWithAggregatesFilter } from \\"../inputs/NestedIntWithAggregatesFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class IntWithAggregatesFilter {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  equals?: number | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true
  })
<<<<<<< HEAD
  stringField?: string | undefined;
=======
  in?: number[] | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true
  })
  notIn?: number[] | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
<<<<<<< HEAD
  get intIdField() {
    return this.intIdField;
  }

  set intIdField(intIdField: number | undefined) {
    this.intIdField = intIdField;
  }
=======
  lt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  lte?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  gt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  gte?: number | undefined;

  @TypeGraphQL.Field(_type => NestedIntWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedIntWithAggregatesFilter | undefined;

  @TypeGraphQL.Field(_type => NestedIntFilter, {
    nullable: true
  })
  _count?: NestedIntFilter | undefined;

  @TypeGraphQL.Field(_type => NestedFloatFilter, {
    nullable: true
  })
  _avg?: NestedFloatFilter | undefined;

  @TypeGraphQL.Field(_type => NestedIntFilter, {
    nullable: true
  })
  _sum?: NestedIntFilter | undefined;

  @TypeGraphQL.Field(_type => NestedIntFilter, {
    nullable: true
  })
  _min?: NestedIntFilter | undefined;

  @TypeGraphQL.Field(_type => NestedIntFilter, {
    nullable: true
  })
  _max?: NestedIntFilter | undefined;
}
"
`;

exports[`inputs should generate proper WithAggregatesFilter for scalars: JsonWithAggregatesFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedIntFilter } from \\"../inputs/NestedIntFilter\\";
import { NestedJsonFilter } from \\"../inputs/NestedJsonFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class JsonWithAggregatesFilter {
  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  equals?: Prisma.InputJsonValue | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  not?: Prisma.InputJsonValue | undefined;

  @TypeGraphQL.Field(_type => NestedIntFilter, {
    nullable: true
  })
  _count?: NestedIntFilter | undefined;

  @TypeGraphQL.Field(_type => NestedJsonFilter, {
    nullable: true
  })
  _min?: NestedJsonFilter | undefined;

  @TypeGraphQL.Field(_type => NestedJsonFilter, {
    nullable: true
  })
  _max?: NestedJsonFilter | undefined;
}
"
`;

exports[`inputs should generate proper WithAggregatesFilter for scalars: StringWithAggregatesFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedIntFilter } from \\"../inputs/NestedIntFilter\\";
import { NestedStringFilter } from \\"../inputs/NestedStringFilter\\";
import { NestedStringWithAggregatesFilter } from \\"../inputs/NestedStringWithAggregatesFilter\\";
import { QueryMode } from \\"../../enums/QueryMode\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class StringWithAggregatesFilter {
  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  equals?: string | undefined;

  @TypeGraphQL.Field(_type => [String], {
    nullable: true
  })
  in?: string[] | undefined;

  @TypeGraphQL.Field(_type => [String], {
    nullable: true
  })
  notIn?: string[] | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  lt?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  lte?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  gt?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  gte?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  contains?: string | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
<<<<<<< HEAD
  get stringField() {
    return this.stringField;
  }

  set stringField(stringField: string | undefined) {
    this.stringField = stringField;
  }
=======
  startsWith?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  endsWith?: string | undefined;

  @TypeGraphQL.Field(_type => QueryMode, {
    nullable: true
  })
  mode?: \\"default\\" | \\"insensitive\\" | undefined;

  @TypeGraphQL.Field(_type => NestedStringWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedStringWithAggregatesFilter | undefined;

  @TypeGraphQL.Field(_type => NestedIntFilter, {
    nullable: true
  })
  _count?: NestedIntFilter | undefined;

  @TypeGraphQL.Field(_type => NestedStringFilter, {
    nullable: true
  })
  _min?: NestedStringFilter | undefined;

  @TypeGraphQL.Field(_type => NestedStringFilter, {
    nullable: true
  })
  _max?: NestedStringFilter | undefined;
}
"
`;

exports[`inputs should generate proper WithAggregatesFilter for scalars: index 1`] = `
"export { BoolFieldUpdateOperationsInput } from \\"./BoolFieldUpdateOperationsInput\\";
export { BoolFilter } from \\"./BoolFilter\\";
export { BoolWithAggregatesFilter } from \\"./BoolWithAggregatesFilter\\";
export { DateTimeFieldUpdateOperationsInput } from \\"./DateTimeFieldUpdateOperationsInput\\";
export { DateTimeFilter } from \\"./DateTimeFilter\\";
export { DateTimeWithAggregatesFilter } from \\"./DateTimeWithAggregatesFilter\\";
export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { FloatWithAggregatesFilter } from \\"./FloatWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { JsonFilter } from \\"./JsonFilter\\";
export { JsonWithAggregatesFilter } from \\"./JsonWithAggregatesFilter\\";
export { NestedBoolFilter } from \\"./NestedBoolFilter\\";
export { NestedBoolWithAggregatesFilter } from \\"./NestedBoolWithAggregatesFilter\\";
export { NestedDateTimeFilter } from \\"./NestedDateTimeFilter\\";
export { NestedDateTimeWithAggregatesFilter } from \\"./NestedDateTimeWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatWithAggregatesFilter } from \\"./NestedFloatWithAggregatesFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedJsonFilter } from \\"./NestedJsonFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { SampleCreateInput } from \\"./SampleCreateInput\\";
export { SampleCreateManyInput } from \\"./SampleCreateManyInput\\";
export { SampleOrderByInput } from \\"./SampleOrderByInput\\";
export { SampleScalarWhereWithAggregatesInput } from \\"./SampleScalarWhereWithAggregatesInput\\";
export { SampleUpdateInput } from \\"./SampleUpdateInput\\";
export { SampleUpdateManyMutationInput } from \\"./SampleUpdateManyMutationInput\\";
export { SampleWhereInput } from \\"./SampleWhereInput\\";
export { SampleWhereUniqueInput } from \\"./SampleWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type class for filtering by enums values: EnumColorFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedEnumColorFilter } from \\"../inputs/NestedEnumColorFilter\\";
import { Color } from \\"../../enums/Color\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class EnumColorFilter {
  @TypeGraphQL.Field(_type => Color, {
    nullable: true
  })
  equals?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @TypeGraphQL.Field(_type => [Color], {
    nullable: true
  })
  in?: Array<\\"RED\\" | \\"GREEN\\" | \\"BLUE\\"> | undefined;

  @TypeGraphQL.Field(_type => [Color], {
    nullable: true
  })
  notIn?: Array<\\"RED\\" | \\"GREEN\\" | \\"BLUE\\"> | undefined;

  @TypeGraphQL.Field(_type => NestedEnumColorFilter, {
    nullable: true
  })
  not?: NestedEnumColorFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type class for filtering by enums values: NestedEnumColorFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { Color } from \\"../../enums/Color\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NestedEnumColorFilter {
  @TypeGraphQL.Field(_type => Color, {
    nullable: true
  })
  equals?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @TypeGraphQL.Field(_type => [Color], {
    nullable: true
  })
  in?: Array<\\"RED\\" | \\"GREEN\\" | \\"BLUE\\"> | undefined;

  @TypeGraphQL.Field(_type => [Color], {
    nullable: true
  })
  notIn?: Array<\\"RED\\" | \\"GREEN\\" | \\"BLUE\\"> | undefined;

  @TypeGraphQL.Field(_type => NestedEnumColorFilter, {
    nullable: true
  })
  not?: NestedEnumColorFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type class for filtering by enums values: index 1`] = `
"export { EnumColorFieldUpdateOperationsInput } from \\"./EnumColorFieldUpdateOperationsInput\\";
export { EnumColorFilter } from \\"./EnumColorFilter\\";
export { EnumColorWithAggregatesFilter } from \\"./EnumColorWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { NestedEnumColorFilter } from \\"./NestedEnumColorFilter\\";
export { NestedEnumColorWithAggregatesFilter } from \\"./NestedEnumColorWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { SampleModelCreateInput } from \\"./SampleModelCreateInput\\";
export { SampleModelCreateManyInput } from \\"./SampleModelCreateManyInput\\";
export { SampleModelOrderByInput } from \\"./SampleModelOrderByInput\\";
export { SampleModelScalarWhereWithAggregatesInput } from \\"./SampleModelScalarWhereWithAggregatesInput\\";
export { SampleModelUpdateInput } from \\"./SampleModelUpdateInput\\";
export { SampleModelUpdateManyMutationInput } from \\"./SampleModelUpdateManyMutationInput\\";
export { SampleModelWhereInput } from \\"./SampleModelWhereInput\\";
export { SampleModelWhereUniqueInput } from \\"./SampleModelWhereUniqueInput\\";
"
`;

exports[`inputs should properly generate input type classes for connectOrCreate: UserCreateNestedOneWithoutPostsFieldInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { UserCreateOrConnectWithoutPostsFieldInput } from \\"../inputs/UserCreateOrConnectWithoutPostsFieldInput\\";
import { UserCreateWithoutPostsFieldInput } from \\"../inputs/UserCreateWithoutPostsFieldInput\\";
import { UserWhereUniqueInput } from \\"../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class UserCreateNestedOneWithoutPostsFieldInput {
  @TypeGraphQL.Field(_type => UserCreateWithoutPostsFieldInput, {
    nullable: true
  })
  create?: UserCreateWithoutPostsFieldInput | undefined;

  @TypeGraphQL.Field(_type => UserCreateOrConnectWithoutPostsFieldInput, {
    nullable: true
  })
  connectOrCreate?: UserCreateOrConnectWithoutPostsFieldInput | undefined;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: true
  })
  connect?: UserWhereUniqueInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for connectOrCreate: UserCreateOrConnectWithoutPostsFieldInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { UserCreateWithoutPostsFieldInput } from \\"../inputs/UserCreateWithoutPostsFieldInput\\";
import { UserWhereUniqueInput } from \\"../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class UserCreateOrConnectWithoutPostsFieldInput {
  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;

  @TypeGraphQL.Field(_type => UserCreateWithoutPostsFieldInput, {
    nullable: false
  })
  create!: UserCreateWithoutPostsFieldInput;
}
"
`;

exports[`inputs should properly generate input type classes for connectOrCreate: UserUpdateOneRequiredWithoutPostsFieldInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { UserCreateOrConnectWithoutPostsFieldInput } from \\"../inputs/UserCreateOrConnectWithoutPostsFieldInput\\";
import { UserCreateWithoutPostsFieldInput } from \\"../inputs/UserCreateWithoutPostsFieldInput\\";
import { UserUpdateWithoutPostsFieldInput } from \\"../inputs/UserUpdateWithoutPostsFieldInput\\";
import { UserUpsertWithoutPostsFieldInput } from \\"../inputs/UserUpsertWithoutPostsFieldInput\\";
import { UserWhereUniqueInput } from \\"../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class UserUpdateOneRequiredWithoutPostsFieldInput {
  @TypeGraphQL.Field(_type => UserCreateWithoutPostsFieldInput, {
    nullable: true
  })
  create?: UserCreateWithoutPostsFieldInput | undefined;

  @TypeGraphQL.Field(_type => UserCreateOrConnectWithoutPostsFieldInput, {
    nullable: true
  })
  connectOrCreate?: UserCreateOrConnectWithoutPostsFieldInput | undefined;

  @TypeGraphQL.Field(_type => UserUpsertWithoutPostsFieldInput, {
    nullable: true
  })
  upsert?: UserUpsertWithoutPostsFieldInput | undefined;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: true
  })
  connect?: UserWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => UserUpdateWithoutPostsFieldInput, {
    nullable: true
  })
  update?: UserUpdateWithoutPostsFieldInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for creating models and scalar fields: SampleModelCreateInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SampleModelCreateintArrayFieldInput } from \\"../inputs/SampleModelCreateintArrayFieldInput\\";
import { SampleModelCreatestringArrayFieldInput } from \\"../inputs/SampleModelCreatestringArrayFieldInput\\";
import { Color } from \\"../../enums/Color\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleModelCreateInput {
  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  stringField!: string;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  optionalStringField?: string | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: false
  })
  intField!: number;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  optionalIntField?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: false
  })
  floatField!: number;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  optionalFloatField?: number | undefined;

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: false
  })
  booleanField!: boolean;

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  optionalBooleanField?: boolean | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: false
  })
  dateField!: Date;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  optionalDateField?: Date | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: false
  })
  jsonField!: Prisma.InputJsonValue;

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  optionalJsonField?: Prisma.InputJsonValue | undefined;

  @TypeGraphQL.Field(_type => Color, {
    nullable: false
  })
  enumField!: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\";

  @TypeGraphQL.Field(_type => Color, {
    nullable: true
  })
  optionalEnumField?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @TypeGraphQL.Field(_type => SampleModelCreateintArrayFieldInput, {
    nullable: true
  })
  intArrayField?: SampleModelCreateintArrayFieldInput | undefined;

  @TypeGraphQL.Field(_type => SampleModelCreatestringArrayFieldInput, {
    nullable: true
  })
  stringArrayField?: SampleModelCreatestringArrayFieldInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for creating models and scalar fields: SampleModelCreateManyInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SampleModelCreateManyintArrayFieldInput } from \\"../inputs/SampleModelCreateManyintArrayFieldInput\\";
import { SampleModelCreateManystringArrayFieldInput } from \\"../inputs/SampleModelCreateManystringArrayFieldInput\\";
import { Color } from \\"../../enums/Color\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleModelCreateManyInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  intIdField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  stringField!: string;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  optionalStringField?: string | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: false
  })
  intField!: number;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  optionalIntField?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: false
  })
  floatField!: number;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  optionalFloatField?: number | undefined;

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: false
  })
  booleanField!: boolean;

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  optionalBooleanField?: boolean | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: false
  })
  dateField!: Date;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  optionalDateField?: Date | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: false
  })
  jsonField!: Prisma.InputJsonValue;

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  optionalJsonField?: Prisma.InputJsonValue | undefined;

  @TypeGraphQL.Field(_type => Color, {
    nullable: false
  })
  enumField!: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\";

  @TypeGraphQL.Field(_type => Color, {
    nullable: true
  })
  optionalEnumField?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @TypeGraphQL.Field(_type => SampleModelCreateManyintArrayFieldInput, {
    nullable: true
  })
  intArrayField?: SampleModelCreateManyintArrayFieldInput | undefined;

  @TypeGraphQL.Field(_type => SampleModelCreateManystringArrayFieldInput, {
    nullable: true
  })
  stringArrayField?: SampleModelCreateManystringArrayFieldInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for creating models and scalar fields: SampleModelCreateManyintArrayFieldInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleModelCreateManyintArrayFieldInput {
  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: false
  })
  set!: number[];
}
"
`;

exports[`inputs should properly generate input type classes for creating models and scalar fields: SampleModelCreateManystringArrayFieldInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleModelCreateManystringArrayFieldInput {
  @TypeGraphQL.Field(_type => [String], {
    nullable: false
  })
  set!: string[];
}
"
`;

exports[`inputs should properly generate input type classes for creating models and scalar fields: SampleModelCreateintArrayFieldInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleModelCreateintArrayFieldInput {
  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: false
  })
  set!: number[];
}
"
`;

exports[`inputs should properly generate input type classes for creating models and scalar fields: SampleModelCreatestringArrayFieldInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleModelCreatestringArrayFieldInput {
  @TypeGraphQL.Field(_type => [String], {
    nullable: false
  })
  set!: string[];
}
"
`;

exports[`inputs should properly generate input type classes for creating models and scalar fields: index 1`] = `
"export { BoolFieldUpdateOperationsInput } from \\"./BoolFieldUpdateOperationsInput\\";
export { BoolFilter } from \\"./BoolFilter\\";
export { BoolNullableFilter } from \\"./BoolNullableFilter\\";
export { BoolNullableWithAggregatesFilter } from \\"./BoolNullableWithAggregatesFilter\\";
export { BoolWithAggregatesFilter } from \\"./BoolWithAggregatesFilter\\";
export { DateTimeFieldUpdateOperationsInput } from \\"./DateTimeFieldUpdateOperationsInput\\";
export { DateTimeFilter } from \\"./DateTimeFilter\\";
export { DateTimeNullableFilter } from \\"./DateTimeNullableFilter\\";
export { DateTimeNullableWithAggregatesFilter } from \\"./DateTimeNullableWithAggregatesFilter\\";
export { DateTimeWithAggregatesFilter } from \\"./DateTimeWithAggregatesFilter\\";
export { EnumColorFieldUpdateOperationsInput } from \\"./EnumColorFieldUpdateOperationsInput\\";
export { EnumColorFilter } from \\"./EnumColorFilter\\";
export { EnumColorNullableFilter } from \\"./EnumColorNullableFilter\\";
export { EnumColorNullableWithAggregatesFilter } from \\"./EnumColorNullableWithAggregatesFilter\\";
export { EnumColorWithAggregatesFilter } from \\"./EnumColorWithAggregatesFilter\\";
export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { FloatNullableFilter } from \\"./FloatNullableFilter\\";
export { FloatNullableWithAggregatesFilter } from \\"./FloatNullableWithAggregatesFilter\\";
export { FloatWithAggregatesFilter } from \\"./FloatWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntNullableFilter } from \\"./IntNullableFilter\\";
export { IntNullableListFilter } from \\"./IntNullableListFilter\\";
export { IntNullableWithAggregatesFilter } from \\"./IntNullableWithAggregatesFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { JsonFilter } from \\"./JsonFilter\\";
export { JsonNullableFilter } from \\"./JsonNullableFilter\\";
export { JsonNullableWithAggregatesFilter } from \\"./JsonNullableWithAggregatesFilter\\";
export { JsonWithAggregatesFilter } from \\"./JsonWithAggregatesFilter\\";
export { NestedBoolFilter } from \\"./NestedBoolFilter\\";
export { NestedBoolNullableFilter } from \\"./NestedBoolNullableFilter\\";
export { NestedBoolNullableWithAggregatesFilter } from \\"./NestedBoolNullableWithAggregatesFilter\\";
export { NestedBoolWithAggregatesFilter } from \\"./NestedBoolWithAggregatesFilter\\";
export { NestedDateTimeFilter } from \\"./NestedDateTimeFilter\\";
export { NestedDateTimeNullableFilter } from \\"./NestedDateTimeNullableFilter\\";
export { NestedDateTimeNullableWithAggregatesFilter } from \\"./NestedDateTimeNullableWithAggregatesFilter\\";
export { NestedDateTimeWithAggregatesFilter } from \\"./NestedDateTimeWithAggregatesFilter\\";
export { NestedEnumColorFilter } from \\"./NestedEnumColorFilter\\";
export { NestedEnumColorNullableFilter } from \\"./NestedEnumColorNullableFilter\\";
export { NestedEnumColorNullableWithAggregatesFilter } from \\"./NestedEnumColorNullableWithAggregatesFilter\\";
export { NestedEnumColorWithAggregatesFilter } from \\"./NestedEnumColorWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatNullableFilter } from \\"./NestedFloatNullableFilter\\";
export { NestedFloatNullableWithAggregatesFilter } from \\"./NestedFloatNullableWithAggregatesFilter\\";
export { NestedFloatWithAggregatesFilter } from \\"./NestedFloatWithAggregatesFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntNullableFilter } from \\"./NestedIntNullableFilter\\";
export { NestedIntNullableWithAggregatesFilter } from \\"./NestedIntNullableWithAggregatesFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedJsonFilter } from \\"./NestedJsonFilter\\";
export { NestedJsonNullableFilter } from \\"./NestedJsonNullableFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringNullableFilter } from \\"./NestedStringNullableFilter\\";
export { NestedStringNullableWithAggregatesFilter } from \\"./NestedStringNullableWithAggregatesFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { NullableBoolFieldUpdateOperationsInput } from \\"./NullableBoolFieldUpdateOperationsInput\\";
export { NullableDateTimeFieldUpdateOperationsInput } from \\"./NullableDateTimeFieldUpdateOperationsInput\\";
export { NullableEnumColorFieldUpdateOperationsInput } from \\"./NullableEnumColorFieldUpdateOperationsInput\\";
export { NullableFloatFieldUpdateOperationsInput } from \\"./NullableFloatFieldUpdateOperationsInput\\";
export { NullableIntFieldUpdateOperationsInput } from \\"./NullableIntFieldUpdateOperationsInput\\";
export { NullableStringFieldUpdateOperationsInput } from \\"./NullableStringFieldUpdateOperationsInput\\";
export { SampleModelCreateInput } from \\"./SampleModelCreateInput\\";
export { SampleModelCreateManyInput } from \\"./SampleModelCreateManyInput\\";
export { SampleModelCreateManyintArrayFieldInput } from \\"./SampleModelCreateManyintArrayFieldInput\\";
export { SampleModelCreateManystringArrayFieldInput } from \\"./SampleModelCreateManystringArrayFieldInput\\";
export { SampleModelCreateintArrayFieldInput } from \\"./SampleModelCreateintArrayFieldInput\\";
export { SampleModelCreatestringArrayFieldInput } from \\"./SampleModelCreatestringArrayFieldInput\\";
export { SampleModelOrderByInput } from \\"./SampleModelOrderByInput\\";
export { SampleModelScalarWhereWithAggregatesInput } from \\"./SampleModelScalarWhereWithAggregatesInput\\";
export { SampleModelUpdateInput } from \\"./SampleModelUpdateInput\\";
export { SampleModelUpdateManyMutationInput } from \\"./SampleModelUpdateManyMutationInput\\";
export { SampleModelUpdateintArrayFieldInput } from \\"./SampleModelUpdateintArrayFieldInput\\";
export { SampleModelUpdatestringArrayFieldInput } from \\"./SampleModelUpdatestringArrayFieldInput\\";
export { SampleModelWhereInput } from \\"./SampleModelWhereInput\\";
export { SampleModelWhereUniqueInput } from \\"./SampleModelWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringNullableFilter } from \\"./StringNullableFilter\\";
export { StringNullableListFilter } from \\"./StringNullableListFilter\\";
export { StringNullableWithAggregatesFilter } from \\"./StringNullableWithAggregatesFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for filtering models by fields: SampleModelWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { BoolFilter } from \\"../inputs/BoolFilter\\";
import { DateTimeFilter } from \\"../inputs/DateTimeFilter\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { JsonFilter } from \\"../inputs/JsonFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";
import { StringNullableFilter } from \\"../inputs/StringNullableFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleModelWhereInput {
  @TypeGraphQL.Field(_type => [SampleModelWhereInput], {
    nullable: true
  })
  AND?: SampleModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleModelWhereInput], {
    nullable: true
  })
  OR?: SampleModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleModelWhereInput], {
    nullable: true
  })
  NOT?: SampleModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  intIdField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  stringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => StringNullableFilter, {
    nullable: true
  })
  optionalStringField?: StringNullableFilter | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  intField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => BoolFilter, {
    nullable: true
  })
  booleanField?: BoolFilter | undefined;

  @TypeGraphQL.Field(_type => DateTimeFilter, {
    nullable: true
  })
  dateField?: DateTimeFilter | undefined;

  @TypeGraphQL.Field(_type => JsonFilter, {
    nullable: true
  })
  jsonField?: JsonFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by fields: SampleModelWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleModelWhereUniqueInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  intIdField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  stringField?: string | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by fields: index 1`] = `
"export { BoolFieldUpdateOperationsInput } from \\"./BoolFieldUpdateOperationsInput\\";
export { BoolFilter } from \\"./BoolFilter\\";
export { BoolWithAggregatesFilter } from \\"./BoolWithAggregatesFilter\\";
export { DateTimeFieldUpdateOperationsInput } from \\"./DateTimeFieldUpdateOperationsInput\\";
export { DateTimeFilter } from \\"./DateTimeFilter\\";
export { DateTimeWithAggregatesFilter } from \\"./DateTimeWithAggregatesFilter\\";
export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { FloatWithAggregatesFilter } from \\"./FloatWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { JsonFilter } from \\"./JsonFilter\\";
export { JsonWithAggregatesFilter } from \\"./JsonWithAggregatesFilter\\";
export { NestedBoolFilter } from \\"./NestedBoolFilter\\";
export { NestedBoolWithAggregatesFilter } from \\"./NestedBoolWithAggregatesFilter\\";
export { NestedDateTimeFilter } from \\"./NestedDateTimeFilter\\";
export { NestedDateTimeWithAggregatesFilter } from \\"./NestedDateTimeWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatWithAggregatesFilter } from \\"./NestedFloatWithAggregatesFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntNullableFilter } from \\"./NestedIntNullableFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedJsonFilter } from \\"./NestedJsonFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringNullableFilter } from \\"./NestedStringNullableFilter\\";
export { NestedStringNullableWithAggregatesFilter } from \\"./NestedStringNullableWithAggregatesFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { NullableStringFieldUpdateOperationsInput } from \\"./NullableStringFieldUpdateOperationsInput\\";
export { SampleModelCreateInput } from \\"./SampleModelCreateInput\\";
export { SampleModelCreateManyInput } from \\"./SampleModelCreateManyInput\\";
export { SampleModelOrderByInput } from \\"./SampleModelOrderByInput\\";
export { SampleModelScalarWhereWithAggregatesInput } from \\"./SampleModelScalarWhereWithAggregatesInput\\";
export { SampleModelUpdateInput } from \\"./SampleModelUpdateInput\\";
export { SampleModelUpdateManyMutationInput } from \\"./SampleModelUpdateManyMutationInput\\";
export { SampleModelWhereInput } from \\"./SampleModelWhereInput\\";
export { SampleModelWhereUniqueInput } from \\"./SampleModelWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringNullableFilter } from \\"./StringNullableFilter\\";
export { StringNullableWithAggregatesFilter } from \\"./StringNullableWithAggregatesFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for filtering models by many to many relation fields: FirstModelOrderByInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelOrderByInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: \\"asc\\" | \\"desc\\" | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: \\"asc\\" | \\"desc\\" | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: \\"asc\\" | \\"desc\\" | undefined) {
    this.floatField = floatField;
  }
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by many to many relation fields: FirstModelScalarWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelScalarWhereInput {
  @TypeGraphQL.Field(_type => [FirstModelScalarWhereInput], {
    nullable: true
  })
  AND?: FirstModelScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [FirstModelScalarWhereInput], {
    nullable: true
  })
  OR?: FirstModelScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [FirstModelScalarWhereInput], {
    nullable: true
  })
  NOT?: FirstModelScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => [FirstModelScalarWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: FirstModelScalarWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [FirstModelScalarWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: FirstModelScalarWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [FirstModelScalarWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: FirstModelScalarWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: IntFilter | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: StringFilter | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFilter | undefined) {
    this.floatField = floatField;
  }
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by many to many relation fields: FirstModelWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { SecondModelListRelationFilter } from \\"../inputs/SecondModelListRelationFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelWhereInput {
  @TypeGraphQL.Field(_type => [FirstModelWhereInput], {
    nullable: true
  })
  AND?: FirstModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [FirstModelWhereInput], {
    nullable: true
  })
  OR?: FirstModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [FirstModelWhereInput], {
    nullable: true
  })
  NOT?: FirstModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => SecondModelListRelationFilter, {
    nullable: true
  })
  secondModelsField?: SecondModelListRelationFilter | undefined;

  @TypeGraphQL.Field(_type => [FirstModelWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: FirstModelWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [FirstModelWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: FirstModelWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [FirstModelWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: FirstModelWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: IntFilter | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: StringFilter | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFilter | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => SecondModelListRelationFilter, {
    nullable: true
  })
  get secondModelsField() {
    return this.secondModelsField;
  }

  set secondModelsField(secondModelsField: SecondModelListRelationFilter | undefined) {
    this.secondModelsField = secondModelsField;
  }
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by many to many relation fields: FirstModelWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelWhereUniqueInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  idField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  uniqueStringField?: string | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: number | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: string | undefined) {
    this.uniqueStringField = uniqueStringField;
  }
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by many to many relation fields: index 1`] = `
"export { FirstModelCreateInput } from \\"./FirstModelCreateInput\\";
export { FirstModelCreateManyInput } from \\"./FirstModelCreateManyInput\\";
export { FirstModelCreateNestedManyWithoutSecondModelsFieldInput } from \\"./FirstModelCreateNestedManyWithoutSecondModelsFieldInput\\";
export { FirstModelCreateOrConnectWithoutSecondModelsFieldInput } from \\"./FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export { FirstModelCreateWithoutSecondModelsFieldInput } from \\"./FirstModelCreateWithoutSecondModelsFieldInput\\";
export { FirstModelListRelationFilter } from \\"./FirstModelListRelationFilter\\";
export { FirstModelOrderByInput } from \\"./FirstModelOrderByInput\\";
export { FirstModelScalarWhereInput } from \\"./FirstModelScalarWhereInput\\";
export { FirstModelScalarWhereWithAggregatesInput } from \\"./FirstModelScalarWhereWithAggregatesInput\\";
export { FirstModelUpdateInput } from \\"./FirstModelUpdateInput\\";
export { FirstModelUpdateManyMutationInput } from \\"./FirstModelUpdateManyMutationInput\\";
export { FirstModelUpdateManyWithWhereWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateManyWithWhereWithoutSecondModelsFieldInput\\";
export { FirstModelUpdateManyWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateManyWithoutSecondModelsFieldInput\\";
export { FirstModelUpdateWithWhereUniqueWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateWithWhereUniqueWithoutSecondModelsFieldInput\\";
export { FirstModelUpdateWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateWithoutSecondModelsFieldInput\\";
export { FirstModelUpsertWithWhereUniqueWithoutSecondModelsFieldInput } from \\"./FirstModelUpsertWithWhereUniqueWithoutSecondModelsFieldInput\\";
export { FirstModelWhereInput } from \\"./FirstModelWhereInput\\";
export { FirstModelWhereUniqueInput } from \\"./FirstModelWhereUniqueInput\\";
export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { FloatWithAggregatesFilter } from \\"./FloatWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatWithAggregatesFilter } from \\"./NestedFloatWithAggregatesFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { SecondModelCreateInput } from \\"./SecondModelCreateInput\\";
export { SecondModelCreateManyInput } from \\"./SecondModelCreateManyInput\\";
export { SecondModelCreateNestedManyWithoutFirstModelsFieldInput } from \\"./SecondModelCreateNestedManyWithoutFirstModelsFieldInput\\";
export { SecondModelCreateOrConnectWithoutFirstModelsFieldInput } from \\"./SecondModelCreateOrConnectWithoutFirstModelsFieldInput\\";
export { SecondModelCreateWithoutFirstModelsFieldInput } from \\"./SecondModelCreateWithoutFirstModelsFieldInput\\";
export { SecondModelListRelationFilter } from \\"./SecondModelListRelationFilter\\";
export { SecondModelOrderByInput } from \\"./SecondModelOrderByInput\\";
export { SecondModelScalarWhereInput } from \\"./SecondModelScalarWhereInput\\";
export { SecondModelScalarWhereWithAggregatesInput } from \\"./SecondModelScalarWhereWithAggregatesInput\\";
export { SecondModelUpdateInput } from \\"./SecondModelUpdateInput\\";
export { SecondModelUpdateManyMutationInput } from \\"./SecondModelUpdateManyMutationInput\\";
export { SecondModelUpdateManyWithWhereWithoutFirstModelsFieldInput } from \\"./SecondModelUpdateManyWithWhereWithoutFirstModelsFieldInput\\";
export { SecondModelUpdateManyWithoutFirstModelsFieldInput } from \\"./SecondModelUpdateManyWithoutFirstModelsFieldInput\\";
export { SecondModelUpdateWithWhereUniqueWithoutFirstModelsFieldInput } from \\"./SecondModelUpdateWithWhereUniqueWithoutFirstModelsFieldInput\\";
export { SecondModelUpdateWithoutFirstModelsFieldInput } from \\"./SecondModelUpdateWithoutFirstModelsFieldInput\\";
export { SecondModelUpsertWithWhereUniqueWithoutFirstModelsFieldInput } from \\"./SecondModelUpsertWithWhereUniqueWithoutFirstModelsFieldInput\\";
export { SecondModelWhereInput } from \\"./SecondModelWhereInput\\";
export { SecondModelWhereUniqueInput } from \\"./SecondModelWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: FirstModelOrderByInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelOrderByInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: \\"asc\\" | \\"desc\\" | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: \\"asc\\" | \\"desc\\" | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: \\"asc\\" | \\"desc\\" | undefined) {
    this.floatField = floatField;
  }
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: FirstModelRelationFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelWhereInput } from \\"../inputs/FirstModelWhereInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelRelationFilter {
  @TypeGraphQL.Field(_type => FirstModelWhereInput, {
    nullable: true
  })
  is?: FirstModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => FirstModelWhereInput, {
    nullable: true
  })
  isNot?: FirstModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => FirstModelWhereInput, {
    nullable: true
  })
  get is() {
    return this.is;
  }

  set is(is: FirstModelWhereInput | undefined) {
    this.is = is;
  }

  @TypeGraphQL.Field(_type => FirstModelWhereInput, {
    nullable: true
  })
  get isNot() {
    return this.isNot;
  }

  set isNot(isNot: FirstModelWhereInput | undefined) {
    this.isNot = isNot;
  }
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: FirstModelWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { SecondModelListRelationFilter } from \\"../inputs/SecondModelListRelationFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelWhereInput {
  @TypeGraphQL.Field(_type => [FirstModelWhereInput], {
    nullable: true
  })
  AND?: FirstModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [FirstModelWhereInput], {
    nullable: true
  })
  OR?: FirstModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [FirstModelWhereInput], {
    nullable: true
  })
  NOT?: FirstModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => SecondModelListRelationFilter, {
    nullable: true
  })
  secondModelsField?: SecondModelListRelationFilter | undefined;

  @TypeGraphQL.Field(_type => [FirstModelWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: FirstModelWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [FirstModelWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: FirstModelWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [FirstModelWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: FirstModelWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: IntFilter | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: StringFilter | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFilter | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => SecondModelListRelationFilter, {
    nullable: true
  })
  get secondModelsField() {
    return this.secondModelsField;
  }

  set secondModelsField(secondModelsField: SecondModelListRelationFilter | undefined) {
    this.secondModelsField = secondModelsField;
  }
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: FirstModelWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelWhereUniqueInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  idField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  uniqueStringField?: string | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: number | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: string | undefined) {
    this.uniqueStringField = uniqueStringField;
  }
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: SecondModelListRelationFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SecondModelWhereInput } from \\"../inputs/SecondModelWhereInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SecondModelListRelationFilter {
  @TypeGraphQL.Field(_type => SecondModelWhereInput, {
    nullable: true
  })
  every?: SecondModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => SecondModelWhereInput, {
    nullable: true
  })
  some?: SecondModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => SecondModelWhereInput, {
    nullable: true
  })
  none?: SecondModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => SecondModelWhereInput, {
    nullable: true
  })
  get every() {
    return this.every;
  }

  set every(every: SecondModelWhereInput | undefined) {
    this.every = every;
  }

  @TypeGraphQL.Field(_type => SecondModelWhereInput, {
    nullable: true
  })
  get some() {
    return this.some;
  }

  set some(some: SecondModelWhereInput | undefined) {
    this.some = some;
  }

  @TypeGraphQL.Field(_type => SecondModelWhereInput, {
    nullable: true
  })
  get none() {
    return this.none;
  }

  set none(none: SecondModelWhereInput | undefined) {
    this.none = none;
  }
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: SecondModelOrderByInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SecondModelOrderByInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  firstModelFieldId?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: \\"asc\\" | \\"desc\\" | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: \\"asc\\" | \\"desc\\" | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: \\"asc\\" | \\"desc\\" | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get firstModelFieldId() {
    return this.firstModelFieldId;
  }

  set firstModelFieldId(firstModelFieldId: \\"asc\\" | \\"desc\\" | undefined) {
    this.firstModelFieldId = firstModelFieldId;
  }
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: SecondModelScalarWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SecondModelScalarWhereInput {
  @TypeGraphQL.Field(_type => [SecondModelScalarWhereInput], {
    nullable: true
  })
  AND?: SecondModelScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SecondModelScalarWhereInput], {
    nullable: true
  })
  OR?: SecondModelScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SecondModelScalarWhereInput], {
    nullable: true
  })
  NOT?: SecondModelScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  firstModelFieldId?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => [SecondModelScalarWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: SecondModelScalarWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [SecondModelScalarWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: SecondModelScalarWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [SecondModelScalarWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: SecondModelScalarWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: IntFilter | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: StringFilter | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFilter | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get firstModelFieldId() {
    return this.firstModelFieldId;
  }

  set firstModelFieldId(firstModelFieldId: IntFilter | undefined) {
    this.firstModelFieldId = firstModelFieldId;
  }
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: SecondModelWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelRelationFilter } from \\"../inputs/FirstModelRelationFilter\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SecondModelWhereInput {
  @TypeGraphQL.Field(_type => [SecondModelWhereInput], {
    nullable: true
  })
  AND?: SecondModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SecondModelWhereInput], {
    nullable: true
  })
  OR?: SecondModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SecondModelWhereInput], {
    nullable: true
  })
  NOT?: SecondModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  firstModelFieldId?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => FirstModelRelationFilter, {
    nullable: true
  })
  firstModelField?: FirstModelRelationFilter | undefined;

  @TypeGraphQL.Field(_type => [SecondModelWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: SecondModelWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [SecondModelWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: SecondModelWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [SecondModelWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: SecondModelWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: IntFilter | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: StringFilter | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFilter | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get firstModelFieldId() {
    return this.firstModelFieldId;
  }

  set firstModelFieldId(firstModelFieldId: IntFilter | undefined) {
    this.firstModelFieldId = firstModelFieldId;
  }

  @TypeGraphQL.Field(_type => FirstModelRelationFilter, {
    nullable: true
  })
  get firstModelField() {
    return this.firstModelField;
  }

  set firstModelField(firstModelField: FirstModelRelationFilter | undefined) {
    this.firstModelField = firstModelField;
  }
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: SecondModelWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SecondModelWhereUniqueInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  idField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  uniqueStringField?: string | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: number | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: string | undefined) {
    this.uniqueStringField = uniqueStringField;
  }
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: index 1`] = `
"export { FirstModelCreateInput } from \\"./FirstModelCreateInput\\";
export { FirstModelCreateManyInput } from \\"./FirstModelCreateManyInput\\";
export { FirstModelCreateNestedOneWithoutSecondModelsFieldInput } from \\"./FirstModelCreateNestedOneWithoutSecondModelsFieldInput\\";
export { FirstModelCreateOrConnectWithoutSecondModelsFieldInput } from \\"./FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export { FirstModelCreateWithoutSecondModelsFieldInput } from \\"./FirstModelCreateWithoutSecondModelsFieldInput\\";
export { FirstModelOrderByInput } from \\"./FirstModelOrderByInput\\";
export { FirstModelRelationFilter } from \\"./FirstModelRelationFilter\\";
export { FirstModelScalarWhereWithAggregatesInput } from \\"./FirstModelScalarWhereWithAggregatesInput\\";
export { FirstModelUpdateInput } from \\"./FirstModelUpdateInput\\";
export { FirstModelUpdateManyMutationInput } from \\"./FirstModelUpdateManyMutationInput\\";
export { FirstModelUpdateOneRequiredWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateOneRequiredWithoutSecondModelsFieldInput\\";
export { FirstModelUpdateWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateWithoutSecondModelsFieldInput\\";
export { FirstModelUpsertWithoutSecondModelsFieldInput } from \\"./FirstModelUpsertWithoutSecondModelsFieldInput\\";
export { FirstModelWhereInput } from \\"./FirstModelWhereInput\\";
export { FirstModelWhereUniqueInput } from \\"./FirstModelWhereUniqueInput\\";
export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { FloatWithAggregatesFilter } from \\"./FloatWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatWithAggregatesFilter } from \\"./NestedFloatWithAggregatesFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { SecondModelCreateInput } from \\"./SecondModelCreateInput\\";
export { SecondModelCreateManyFirstModelFieldInput } from \\"./SecondModelCreateManyFirstModelFieldInput\\";
export { SecondModelCreateManyFirstModelFieldInputEnvelope } from \\"./SecondModelCreateManyFirstModelFieldInputEnvelope\\";
export { SecondModelCreateManyInput } from \\"./SecondModelCreateManyInput\\";
export { SecondModelCreateNestedManyWithoutFirstModelFieldInput } from \\"./SecondModelCreateNestedManyWithoutFirstModelFieldInput\\";
export { SecondModelCreateOrConnectWithoutFirstModelFieldInput } from \\"./SecondModelCreateOrConnectWithoutFirstModelFieldInput\\";
export { SecondModelCreateWithoutFirstModelFieldInput } from \\"./SecondModelCreateWithoutFirstModelFieldInput\\";
export { SecondModelListRelationFilter } from \\"./SecondModelListRelationFilter\\";
export { SecondModelOrderByInput } from \\"./SecondModelOrderByInput\\";
export { SecondModelScalarWhereInput } from \\"./SecondModelScalarWhereInput\\";
export { SecondModelScalarWhereWithAggregatesInput } from \\"./SecondModelScalarWhereWithAggregatesInput\\";
export { SecondModelUpdateInput } from \\"./SecondModelUpdateInput\\";
export { SecondModelUpdateManyMutationInput } from \\"./SecondModelUpdateManyMutationInput\\";
export { SecondModelUpdateManyWithWhereWithoutFirstModelFieldInput } from \\"./SecondModelUpdateManyWithWhereWithoutFirstModelFieldInput\\";
export { SecondModelUpdateManyWithoutFirstModelFieldInput } from \\"./SecondModelUpdateManyWithoutFirstModelFieldInput\\";
export { SecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput } from \\"./SecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput\\";
export { SecondModelUpdateWithoutFirstModelFieldInput } from \\"./SecondModelUpdateWithoutFirstModelFieldInput\\";
export { SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput } from \\"./SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput\\";
export { SecondModelWhereInput } from \\"./SecondModelWhereInput\\";
export { SecondModelWhereUniqueInput } from \\"./SecondModelWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: BoolFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedBoolFilter } from \\"../inputs/NestedBoolFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class BoolFilter {
  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  equals?: boolean | undefined;

  @TypeGraphQL.Field(_type => NestedBoolFilter, {
    nullable: true
  })
  not?: NestedBoolFilter | undefined;

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: boolean | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => NestedBoolFilter, {
    nullable: true
  })
  get not() {
    return this.not;
  }

  set not(not: NestedBoolFilter | undefined) {
    this.not = not;
  }
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: DateTimeFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedDateTimeFilter } from \\"../inputs/NestedDateTimeFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class DateTimeFilter {
  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  equals?: Date | undefined;

  @TypeGraphQL.Field(_type => [Date], {
    nullable: true
  })
  in?: Date[] | undefined;

  @TypeGraphQL.Field(_type => [Date], {
    nullable: true
  })
  notIn?: Date[] | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  lt?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  lte?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  gt?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  gte?: Date | undefined;

  @TypeGraphQL.Field(_type => NestedDateTimeFilter, {
    nullable: true
  })
  not?: NestedDateTimeFilter | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: Date | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [Date], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: Date[] | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [Date], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: Date[] | undefined) {
  this.notIn = notIn;
}

@TypeGraphQL.Field(_type => Date, {
  nullable: true
})
get lt() {
  return this.lt;
}

set lt(lt: Date | undefined) {
  this.lt = lt;
}

@TypeGraphQL.Field(_type => Date, {
  nullable: true
})
get lte() {
  return this.lte;
}

set lte(lte: Date | undefined) {
  this.lte = lte;
}

@TypeGraphQL.Field(_type => Date, {
  nullable: true
})
get gt() {
  return this.gt;
}

set gt(gt: Date | undefined) {
  this.gt = gt;
}

@TypeGraphQL.Field(_type => Date, {
  nullable: true
})
get gte() {
  return this.gte;
}

set gte(gte: Date | undefined) {
  this.gte = gte;
}

@TypeGraphQL.Field(_type => NestedDateTimeFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedDateTimeFilter | undefined) {
  this.not = not;
}
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: FloatFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedFloatFilter } from \\"../inputs/NestedFloatFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FloatFilter {
  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  equals?: number | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Float], {
    nullable: true
  })
  in?: number[] | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Float], {
    nullable: true
  })
  notIn?: number[] | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  lt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  lte?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  gt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  gte?: number | undefined;

  @TypeGraphQL.Field(_type => NestedFloatFilter, {
    nullable: true
  })
  not?: NestedFloatFilter | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: number | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [TypeGraphQL.Float], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: number[] | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [TypeGraphQL.Float], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: number[] | undefined) {
  this.notIn = notIn;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Float, {
  nullable: true
})
get lt() {
  return this.lt;
}

set lt(lt: number | undefined) {
  this.lt = lt;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Float, {
  nullable: true
})
get lte() {
  return this.lte;
}

set lte(lte: number | undefined) {
  this.lte = lte;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Float, {
  nullable: true
})
get gt() {
  return this.gt;
}

set gt(gt: number | undefined) {
  this.gt = gt;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Float, {
  nullable: true
})
get gte() {
  return this.gte;
}

set gte(gte: number | undefined) {
  this.gte = gte;
}

@TypeGraphQL.Field(_type => NestedFloatFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedFloatFilter | undefined) {
  this.not = not;
}
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: IntFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedIntFilter } from \\"../inputs/NestedIntFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class IntFilter {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  equals?: number | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true
  })
  in?: number[] | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true
  })
  notIn?: number[] | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  lt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  lte?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  gt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  gte?: number | undefined;

  @TypeGraphQL.Field(_type => NestedIntFilter, {
    nullable: true
  })
  not?: NestedIntFilter | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: number | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: number[] | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: number[] | undefined) {
  this.notIn = notIn;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Int, {
  nullable: true
})
get lt() {
  return this.lt;
}

set lt(lt: number | undefined) {
  this.lt = lt;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Int, {
  nullable: true
})
get lte() {
  return this.lte;
}

set lte(lte: number | undefined) {
  this.lte = lte;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Int, {
  nullable: true
})
get gt() {
  return this.gt;
}

set gt(gt: number | undefined) {
  this.gt = gt;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Int, {
  nullable: true
})
get gte() {
  return this.gte;
}

set gte(gte: number | undefined) {
  this.gte = gte;
}

@TypeGraphQL.Field(_type => NestedIntFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedIntFilter | undefined) {
  this.not = not;
}
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: IntNullableListFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class IntNullableListFilter {
  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true
  })
  equals?: number[] | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  has?: number | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true
  })
  hasEvery?: number[] | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true
  })
  hasSome?: number[] | undefined;

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  isEmpty?: boolean | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: JsonFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class JsonFilter {
  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  equals?: Prisma.InputJsonValue | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  not?: Prisma.InputJsonValue | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: Prisma.InputJsonValue | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  get not() {
    return this.not;
  }

  set not(not: Prisma.InputJsonValue | undefined) {
    this.not = not;
  }
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: NestedBoolFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NestedBoolFilter {
  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  equals?: boolean | undefined;

  @TypeGraphQL.Field(_type => NestedBoolFilter, {
    nullable: true
  })
  not?: NestedBoolFilter | undefined;

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: boolean | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => NestedBoolFilter, {
    nullable: true
  })
  get not() {
    return this.not;
  }

  set not(not: NestedBoolFilter | undefined) {
    this.not = not;
  }
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: NestedDateTimeFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NestedDateTimeFilter {
  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  equals?: Date | undefined;

  @TypeGraphQL.Field(_type => [Date], {
    nullable: true
  })
  in?: Date[] | undefined;

  @TypeGraphQL.Field(_type => [Date], {
    nullable: true
  })
  notIn?: Date[] | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  lt?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  lte?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  gt?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  gte?: Date | undefined;

  @TypeGraphQL.Field(_type => NestedDateTimeFilter, {
    nullable: true
  })
  not?: NestedDateTimeFilter | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: Date | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [Date], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: Date[] | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [Date], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: Date[] | undefined) {
  this.notIn = notIn;
}

@TypeGraphQL.Field(_type => Date, {
  nullable: true
})
get lt() {
  return this.lt;
}

set lt(lt: Date | undefined) {
  this.lt = lt;
}

@TypeGraphQL.Field(_type => Date, {
  nullable: true
})
get lte() {
  return this.lte;
}

set lte(lte: Date | undefined) {
  this.lte = lte;
}

@TypeGraphQL.Field(_type => Date, {
  nullable: true
})
get gt() {
  return this.gt;
}

set gt(gt: Date | undefined) {
  this.gt = gt;
}

@TypeGraphQL.Field(_type => Date, {
  nullable: true
})
get gte() {
  return this.gte;
}

set gte(gte: Date | undefined) {
  this.gte = gte;
}

@TypeGraphQL.Field(_type => NestedDateTimeFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedDateTimeFilter | undefined) {
  this.not = not;
}
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: NestedFloatFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NestedFloatFilter {
  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  equals?: number | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Float], {
    nullable: true
  })
  in?: number[] | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Float], {
    nullable: true
  })
  notIn?: number[] | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  lt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  lte?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  gt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  gte?: number | undefined;

  @TypeGraphQL.Field(_type => NestedFloatFilter, {
    nullable: true
  })
  not?: NestedFloatFilter | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: number | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [TypeGraphQL.Float], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: number[] | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [TypeGraphQL.Float], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: number[] | undefined) {
  this.notIn = notIn;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Float, {
  nullable: true
})
get lt() {
  return this.lt;
}

set lt(lt: number | undefined) {
  this.lt = lt;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Float, {
  nullable: true
})
get lte() {
  return this.lte;
}

set lte(lte: number | undefined) {
  this.lte = lte;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Float, {
  nullable: true
})
get gt() {
  return this.gt;
}

set gt(gt: number | undefined) {
  this.gt = gt;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Float, {
  nullable: true
})
get gte() {
  return this.gte;
}

set gte(gte: number | undefined) {
  this.gte = gte;
}

@TypeGraphQL.Field(_type => NestedFloatFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedFloatFilter | undefined) {
  this.not = not;
}
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: NestedIntFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NestedIntFilter {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  equals?: number | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true
  })
  in?: number[] | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true
  })
  notIn?: number[] | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  lt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  lte?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  gt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  gte?: number | undefined;

  @TypeGraphQL.Field(_type => NestedIntFilter, {
    nullable: true
  })
  not?: NestedIntFilter | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: number | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: number[] | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: number[] | undefined) {
  this.notIn = notIn;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Int, {
  nullable: true
})
get lt() {
  return this.lt;
}

set lt(lt: number | undefined) {
  this.lt = lt;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Int, {
  nullable: true
})
get lte() {
  return this.lte;
}

set lte(lte: number | undefined) {
  this.lte = lte;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Int, {
  nullable: true
})
get gt() {
  return this.gt;
}

set gt(gt: number | undefined) {
  this.gt = gt;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Int, {
  nullable: true
})
get gte() {
  return this.gte;
}

set gte(gte: number | undefined) {
  this.gte = gte;
}

@TypeGraphQL.Field(_type => NestedIntFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedIntFilter | undefined) {
  this.not = not;
}
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: NestedStringNullableFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NestedStringNullableFilter {
  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  equals?: string | undefined;

  @TypeGraphQL.Field(_type => [String], {
    nullable: true
  })
  in?: string[] | undefined;

  @TypeGraphQL.Field(_type => [String], {
    nullable: true
  })
  notIn?: string[] | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  lt?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  lte?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  gt?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  gte?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  contains?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  startsWith?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  endsWith?: string | undefined;

  @TypeGraphQL.Field(_type => NestedStringNullableFilter, {
    nullable: true
  })
  not?: NestedStringNullableFilter | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: string | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [String], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: string[] | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [String], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: string[] | undefined) {
  this.notIn = notIn;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get lt() {
  return this.lt;
}

set lt(lt: string | undefined) {
  this.lt = lt;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get lte() {
  return this.lte;
}

set lte(lte: string | undefined) {
  this.lte = lte;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get gt() {
  return this.gt;
}

set gt(gt: string | undefined) {
  this.gt = gt;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get gte() {
  return this.gte;
}

set gte(gte: string | undefined) {
  this.gte = gte;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get contains() {
  return this.contains;
}

set contains(contains: string | undefined) {
  this.contains = contains;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get startsWith() {
  return this.startsWith;
}

set startsWith(startsWith: string | undefined) {
  this.startsWith = startsWith;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get endsWith() {
  return this.endsWith;
}

set endsWith(endsWith: string | undefined) {
  this.endsWith = endsWith;
}

@TypeGraphQL.Field(_type => NestedStringNullableFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedStringNullableFilter | undefined) {
  this.not = not;
}
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: StringFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedStringFilter } from \\"../inputs/NestedStringFilter\\";
import { QueryMode } from \\"../../enums/QueryMode\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class StringFilter {
  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  equals?: string | undefined;

  @TypeGraphQL.Field(_type => [String], {
    nullable: true
  })
  in?: string[] | undefined;

  @TypeGraphQL.Field(_type => [String], {
    nullable: true
  })
  notIn?: string[] | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  lt?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  lte?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  gt?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  gte?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  contains?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  startsWith?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  endsWith?: string | undefined;

  @TypeGraphQL.Field(_type => QueryMode, {
    nullable: true
  })
  mode?: \\"default\\" | \\"insensitive\\" | undefined;

  @TypeGraphQL.Field(_type => NestedStringFilter, {
    nullable: true
  })
  not?: NestedStringFilter | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: string | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [String], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: string[] | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [String], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: string[] | undefined) {
  this.notIn = notIn;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get lt() {
  return this.lt;
}

set lt(lt: string | undefined) {
  this.lt = lt;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get lte() {
  return this.lte;
}

set lte(lte: string | undefined) {
  this.lte = lte;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get gt() {
  return this.gt;
}

set gt(gt: string | undefined) {
  this.gt = gt;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get gte() {
  return this.gte;
}

set gte(gte: string | undefined) {
  this.gte = gte;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get contains() {
  return this.contains;
}

set contains(contains: string | undefined) {
  this.contains = contains;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get startsWith() {
  return this.startsWith;
}

set startsWith(startsWith: string | undefined) {
  this.startsWith = startsWith;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get endsWith() {
  return this.endsWith;
}

set endsWith(endsWith: string | undefined) {
  this.endsWith = endsWith;
}

@TypeGraphQL.Field(_type => QueryMode, {
  nullable: true
})
get mode() {
  return this.mode;
}

set mode(mode: \\"default\\" | \\"insensitive\\" | undefined) {
  this.mode = mode;
}

@TypeGraphQL.Field(_type => NestedStringFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedStringFilter | undefined) {
  this.not = not;
}
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: StringNullableFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedStringNullableFilter } from \\"../inputs/NestedStringNullableFilter\\";
import { QueryMode } from \\"../../enums/QueryMode\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class StringNullableFilter {
  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  equals?: string | undefined;

  @TypeGraphQL.Field(_type => [String], {
    nullable: true
  })
  in?: string[] | undefined;

  @TypeGraphQL.Field(_type => [String], {
    nullable: true
  })
  notIn?: string[] | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  lt?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  lte?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  gt?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  gte?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  contains?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  startsWith?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  endsWith?: string | undefined;

  @TypeGraphQL.Field(_type => QueryMode, {
    nullable: true
  })
  mode?: \\"default\\" | \\"insensitive\\" | undefined;

  @TypeGraphQL.Field(_type => NestedStringNullableFilter, {
    nullable: true
  })
  not?: NestedStringNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: StringNullableListFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class StringNullableListFilter {
  @TypeGraphQL.Field(_type => [String], {
    nullable: true
  })
  equals?: string[] | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  has?: string | undefined;

  @TypeGraphQL.Field(_type => [String], {
    nullable: true
  })
  hasEvery?: string[] | undefined;

  @TypeGraphQL.Field(_type => [String], {
    nullable: true
  })
  hasSome?: string[] | undefined;

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  isEmpty?: boolean | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: index 1`] = `
"export { BoolFieldUpdateOperationsInput } from \\"./BoolFieldUpdateOperationsInput\\";
export { BoolFilter } from \\"./BoolFilter\\";
export { BoolNullableFilter } from \\"./BoolNullableFilter\\";
export { BoolNullableWithAggregatesFilter } from \\"./BoolNullableWithAggregatesFilter\\";
export { BoolWithAggregatesFilter } from \\"./BoolWithAggregatesFilter\\";
export { DateTimeFieldUpdateOperationsInput } from \\"./DateTimeFieldUpdateOperationsInput\\";
export { DateTimeFilter } from \\"./DateTimeFilter\\";
export { DateTimeNullableFilter } from \\"./DateTimeNullableFilter\\";
export { DateTimeNullableWithAggregatesFilter } from \\"./DateTimeNullableWithAggregatesFilter\\";
export { DateTimeWithAggregatesFilter } from \\"./DateTimeWithAggregatesFilter\\";
export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { FloatNullableFilter } from \\"./FloatNullableFilter\\";
export { FloatNullableWithAggregatesFilter } from \\"./FloatNullableWithAggregatesFilter\\";
export { FloatWithAggregatesFilter } from \\"./FloatWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntNullableFilter } from \\"./IntNullableFilter\\";
export { IntNullableListFilter } from \\"./IntNullableListFilter\\";
export { IntNullableWithAggregatesFilter } from \\"./IntNullableWithAggregatesFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { JsonFilter } from \\"./JsonFilter\\";
export { JsonNullableFilter } from \\"./JsonNullableFilter\\";
export { JsonNullableWithAggregatesFilter } from \\"./JsonNullableWithAggregatesFilter\\";
export { JsonWithAggregatesFilter } from \\"./JsonWithAggregatesFilter\\";
export { NestedBoolFilter } from \\"./NestedBoolFilter\\";
export { NestedBoolNullableFilter } from \\"./NestedBoolNullableFilter\\";
export { NestedBoolNullableWithAggregatesFilter } from \\"./NestedBoolNullableWithAggregatesFilter\\";
export { NestedBoolWithAggregatesFilter } from \\"./NestedBoolWithAggregatesFilter\\";
export { NestedDateTimeFilter } from \\"./NestedDateTimeFilter\\";
export { NestedDateTimeNullableFilter } from \\"./NestedDateTimeNullableFilter\\";
export { NestedDateTimeNullableWithAggregatesFilter } from \\"./NestedDateTimeNullableWithAggregatesFilter\\";
export { NestedDateTimeWithAggregatesFilter } from \\"./NestedDateTimeWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatNullableFilter } from \\"./NestedFloatNullableFilter\\";
export { NestedFloatNullableWithAggregatesFilter } from \\"./NestedFloatNullableWithAggregatesFilter\\";
export { NestedFloatWithAggregatesFilter } from \\"./NestedFloatWithAggregatesFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntNullableFilter } from \\"./NestedIntNullableFilter\\";
export { NestedIntNullableWithAggregatesFilter } from \\"./NestedIntNullableWithAggregatesFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedJsonFilter } from \\"./NestedJsonFilter\\";
export { NestedJsonNullableFilter } from \\"./NestedJsonNullableFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringNullableFilter } from \\"./NestedStringNullableFilter\\";
export { NestedStringNullableWithAggregatesFilter } from \\"./NestedStringNullableWithAggregatesFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { NullableBoolFieldUpdateOperationsInput } from \\"./NullableBoolFieldUpdateOperationsInput\\";
export { NullableDateTimeFieldUpdateOperationsInput } from \\"./NullableDateTimeFieldUpdateOperationsInput\\";
export { NullableFloatFieldUpdateOperationsInput } from \\"./NullableFloatFieldUpdateOperationsInput\\";
export { NullableIntFieldUpdateOperationsInput } from \\"./NullableIntFieldUpdateOperationsInput\\";
export { NullableStringFieldUpdateOperationsInput } from \\"./NullableStringFieldUpdateOperationsInput\\";
export { SampleModelCreateInput } from \\"./SampleModelCreateInput\\";
export { SampleModelCreateManyInput } from \\"./SampleModelCreateManyInput\\";
export { SampleModelCreateManyintArrayFieldInput } from \\"./SampleModelCreateManyintArrayFieldInput\\";
export { SampleModelCreateManystringArrayFieldInput } from \\"./SampleModelCreateManystringArrayFieldInput\\";
export { SampleModelCreateintArrayFieldInput } from \\"./SampleModelCreateintArrayFieldInput\\";
export { SampleModelCreatestringArrayFieldInput } from \\"./SampleModelCreatestringArrayFieldInput\\";
export { SampleModelOrderByInput } from \\"./SampleModelOrderByInput\\";
export { SampleModelScalarWhereWithAggregatesInput } from \\"./SampleModelScalarWhereWithAggregatesInput\\";
export { SampleModelUpdateInput } from \\"./SampleModelUpdateInput\\";
export { SampleModelUpdateManyMutationInput } from \\"./SampleModelUpdateManyMutationInput\\";
export { SampleModelUpdateintArrayFieldInput } from \\"./SampleModelUpdateintArrayFieldInput\\";
export { SampleModelUpdatestringArrayFieldInput } from \\"./SampleModelUpdatestringArrayFieldInput\\";
export { SampleModelWhereInput } from \\"./SampleModelWhereInput\\";
export { SampleModelWhereUniqueInput } from \\"./SampleModelWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringNullableFilter } from \\"./StringNullableFilter\\";
export { StringNullableListFilter } from \\"./StringNullableListFilter\\";
export { StringNullableWithAggregatesFilter } from \\"./StringNullableWithAggregatesFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for inserting many entities: FirstModelCreateManyInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelCreateManyInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  idField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  uniqueStringField!: string;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: false
  })
  floatField!: number;
}
"
`;

exports[`inputs should properly generate input type classes for inserting many entities: SecondModelCreateManyFirstModelFieldInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SecondModelCreateManyFirstModelFieldInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  idField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  uniqueStringField!: string;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: false
  })
  floatField!: number;
}
"
`;

exports[`inputs should properly generate input type classes for inserting many entities: SecondModelCreateManyFirstModelFieldInputEnvelope 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SecondModelCreateManyFirstModelFieldInput } from \\"../inputs/SecondModelCreateManyFirstModelFieldInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SecondModelCreateManyFirstModelFieldInputEnvelope {
  @TypeGraphQL.Field(_type => [SecondModelCreateManyFirstModelFieldInput], {
    nullable: false
  })
  data!: SecondModelCreateManyFirstModelFieldInput[];

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  skipDuplicates?: boolean | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for inserting many entities: SecondModelCreateManyInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SecondModelCreateManyInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  idField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  uniqueStringField!: string;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: false
  })
  floatField!: number;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: false
  })
<<<<<<< HEAD
  not?: NestedStringNullableFilter | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: string | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [String], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: string[] | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [String], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: string[] | undefined) {
  this.notIn = notIn;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get lt() {
  return this.lt;
}

set lt(lt: string | undefined) {
  this.lt = lt;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get lte() {
  return this.lte;
}

set lte(lte: string | undefined) {
  this.lte = lte;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get gt() {
  return this.gt;
}

set gt(gt: string | undefined) {
  this.gt = gt;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get gte() {
  return this.gte;
}

set gte(gte: string | undefined) {
  this.gte = gte;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get contains() {
  return this.contains;
}

set contains(contains: string | undefined) {
  this.contains = contains;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get startsWith() {
  return this.startsWith;
}

set startsWith(startsWith: string | undefined) {
  this.startsWith = startsWith;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get endsWith() {
  return this.endsWith;
}

set endsWith(endsWith: string | undefined) {
  this.endsWith = endsWith;
}

@TypeGraphQL.Field(_type => QueryMode, {
  nullable: true
})
get mode() {
  return this.mode;
}

set mode(mode: \\"default\\" | \\"insensitive\\" | undefined) {
  this.mode = mode;
}

@TypeGraphQL.Field(_type => NestedStringNullableFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedStringNullableFilter | undefined) {
  this.not = not;
}
=======
  firstModelFieldId!: number;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs should properly generate input type classes for inserting many entities: index 1`] = `
"export { FirstModelCreateInput } from \\"./FirstModelCreateInput\\";
export { FirstModelCreateManyInput } from \\"./FirstModelCreateManyInput\\";
export { FirstModelCreateNestedOneWithoutSecondModelsFieldInput } from \\"./FirstModelCreateNestedOneWithoutSecondModelsFieldInput\\";
export { FirstModelCreateOrConnectWithoutSecondModelsFieldInput } from \\"./FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export { FirstModelCreateWithoutSecondModelsFieldInput } from \\"./FirstModelCreateWithoutSecondModelsFieldInput\\";
export { FirstModelOrderByInput } from \\"./FirstModelOrderByInput\\";
export { FirstModelRelationFilter } from \\"./FirstModelRelationFilter\\";
export { FirstModelScalarWhereWithAggregatesInput } from \\"./FirstModelScalarWhereWithAggregatesInput\\";
export { FirstModelUpdateInput } from \\"./FirstModelUpdateInput\\";
export { FirstModelUpdateManyMutationInput } from \\"./FirstModelUpdateManyMutationInput\\";
export { FirstModelUpdateOneRequiredWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateOneRequiredWithoutSecondModelsFieldInput\\";
export { FirstModelUpdateWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateWithoutSecondModelsFieldInput\\";
export { FirstModelUpsertWithoutSecondModelsFieldInput } from \\"./FirstModelUpsertWithoutSecondModelsFieldInput\\";
export { FirstModelWhereInput } from \\"./FirstModelWhereInput\\";
export { FirstModelWhereUniqueInput } from \\"./FirstModelWhereUniqueInput\\";
export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { FloatWithAggregatesFilter } from \\"./FloatWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatWithAggregatesFilter } from \\"./NestedFloatWithAggregatesFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { SecondModelCreateInput } from \\"./SecondModelCreateInput\\";
export { SecondModelCreateManyFirstModelFieldInput } from \\"./SecondModelCreateManyFirstModelFieldInput\\";
export { SecondModelCreateManyFirstModelFieldInputEnvelope } from \\"./SecondModelCreateManyFirstModelFieldInputEnvelope\\";
export { SecondModelCreateManyInput } from \\"./SecondModelCreateManyInput\\";
export { SecondModelCreateNestedManyWithoutFirstModelFieldInput } from \\"./SecondModelCreateNestedManyWithoutFirstModelFieldInput\\";
export { SecondModelCreateOrConnectWithoutFirstModelFieldInput } from \\"./SecondModelCreateOrConnectWithoutFirstModelFieldInput\\";
export { SecondModelCreateWithoutFirstModelFieldInput } from \\"./SecondModelCreateWithoutFirstModelFieldInput\\";
export { SecondModelListRelationFilter } from \\"./SecondModelListRelationFilter\\";
export { SecondModelOrderByInput } from \\"./SecondModelOrderByInput\\";
export { SecondModelScalarWhereInput } from \\"./SecondModelScalarWhereInput\\";
export { SecondModelScalarWhereWithAggregatesInput } from \\"./SecondModelScalarWhereWithAggregatesInput\\";
export { SecondModelUpdateInput } from \\"./SecondModelUpdateInput\\";
export { SecondModelUpdateManyMutationInput } from \\"./SecondModelUpdateManyMutationInput\\";
export { SecondModelUpdateManyWithWhereWithoutFirstModelFieldInput } from \\"./SecondModelUpdateManyWithWhereWithoutFirstModelFieldInput\\";
export { SecondModelUpdateManyWithoutFirstModelFieldInput } from \\"./SecondModelUpdateManyWithoutFirstModelFieldInput\\";
export { SecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput } from \\"./SecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput\\";
export { SecondModelUpdateWithoutFirstModelFieldInput } from \\"./SecondModelUpdateWithoutFirstModelFieldInput\\";
export { SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput } from \\"./SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput\\";
export { SecondModelWhereInput } from \\"./SecondModelWhereInput\\";
export { SecondModelWhereUniqueInput } from \\"./SecondModelWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: DirectorFirstNameLastNameCompoundUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class DirectorFirstNameLastNameCompoundUniqueInput {
  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  firstName!: string;

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  lastName!: string;

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  get firstName() {
    return this.firstName;
  }

  set firstName(firstName: string) {
    this.firstName = firstName;
  }

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  get lastName() {
    return this.lastName;
  }

  set lastName(lastName: string) {
    this.lastName = lastName;
  }
}
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: DirectorOrderByInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class DirectorOrderByInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  firstName?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  lastName?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  age?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get firstName() {
    return this.firstName;
  }

  set firstName(firstName: \\"asc\\" | \\"desc\\" | undefined) {
    this.firstName = firstName;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get lastName() {
    return this.lastName;
  }

  set lastName(lastName: \\"asc\\" | \\"desc\\" | undefined) {
    this.lastName = lastName;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get age() {
    return this.age;
  }

  set age(age: \\"asc\\" | \\"desc\\" | undefined) {
    this.age = age;
  }
}
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: DirectorWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { MovieListRelationFilter } from \\"../inputs/MovieListRelationFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class DirectorWhereInput {
  @TypeGraphQL.Field(_type => [DirectorWhereInput], {
    nullable: true
  })
  AND?: DirectorWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [DirectorWhereInput], {
    nullable: true
  })
  OR?: DirectorWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [DirectorWhereInput], {
    nullable: true
  })
  NOT?: DirectorWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  firstName?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  lastName?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  age?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => MovieListRelationFilter, {
    nullable: true
  })
  movies?: MovieListRelationFilter | undefined;

  @TypeGraphQL.Field(_type => [DirectorWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: DirectorWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [DirectorWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: DirectorWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [DirectorWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: DirectorWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get firstName() {
    return this.firstName;
  }

  set firstName(firstName: StringFilter | undefined) {
    this.firstName = firstName;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get lastName() {
    return this.lastName;
  }

  set lastName(lastName: StringFilter | undefined) {
    this.lastName = lastName;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get age() {
    return this.age;
  }

  set age(age: IntFilter | undefined) {
    this.age = age;
  }

  @TypeGraphQL.Field(_type => MovieListRelationFilter, {
    nullable: true
  })
  get movies() {
    return this.movies;
  }

  set movies(movies: MovieListRelationFilter | undefined) {
    this.movies = movies;
  }
}
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: DirectorWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { DirectorFirstNameLastNameCompoundUniqueInput } from \\"../inputs/DirectorFirstNameLastNameCompoundUniqueInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class DirectorWhereUniqueInput {
  @TypeGraphQL.Field(_type => DirectorFirstNameLastNameCompoundUniqueInput, {
    nullable: true
  })
  firstName_lastName?: DirectorFirstNameLastNameCompoundUniqueInput | undefined;

  @TypeGraphQL.Field(_type => DirectorFirstNameLastNameCompoundUniqueInput, {
    nullable: true
  })
  get firstName_lastName() {
    return this.firstName_lastName;
  }

  set firstName_lastName(firstName_lastName: DirectorFirstNameLastNameCompoundUniqueInput | undefined) {
    this.firstName_lastName = firstName_lastName;
  }
}
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: index 1`] = `
"export { DirectorCreateInput } from \\"./DirectorCreateInput\\";
export { DirectorCreateManyInput } from \\"./DirectorCreateManyInput\\";
export { DirectorCreateNestedOneWithoutMoviesInput } from \\"./DirectorCreateNestedOneWithoutMoviesInput\\";
export { DirectorCreateOrConnectWithoutMoviesInput } from \\"./DirectorCreateOrConnectWithoutMoviesInput\\";
export { DirectorCreateWithoutMoviesInput } from \\"./DirectorCreateWithoutMoviesInput\\";
export { DirectorFirstNameLastNameCompoundUniqueInput } from \\"./DirectorFirstNameLastNameCompoundUniqueInput\\";
export { DirectorOrderByInput } from \\"./DirectorOrderByInput\\";
export { DirectorRelationFilter } from \\"./DirectorRelationFilter\\";
export { DirectorScalarWhereWithAggregatesInput } from \\"./DirectorScalarWhereWithAggregatesInput\\";
export { DirectorUpdateInput } from \\"./DirectorUpdateInput\\";
export { DirectorUpdateManyMutationInput } from \\"./DirectorUpdateManyMutationInput\\";
export { DirectorUpdateOneRequiredWithoutMoviesInput } from \\"./DirectorUpdateOneRequiredWithoutMoviesInput\\";
export { DirectorUpdateWithoutMoviesInput } from \\"./DirectorUpdateWithoutMoviesInput\\";
export { DirectorUpsertWithoutMoviesInput } from \\"./DirectorUpsertWithoutMoviesInput\\";
export { DirectorWhereInput } from \\"./DirectorWhereInput\\";
export { DirectorWhereUniqueInput } from \\"./DirectorWhereUniqueInput\\";
export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { FloatWithAggregatesFilter } from \\"./FloatWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { MovieCreateInput } from \\"./MovieCreateInput\\";
export { MovieCreateManyDirectorInput } from \\"./MovieCreateManyDirectorInput\\";
export { MovieCreateManyDirectorInputEnvelope } from \\"./MovieCreateManyDirectorInputEnvelope\\";
export { MovieCreateManyInput } from \\"./MovieCreateManyInput\\";
export { MovieCreateNestedManyWithoutDirectorInput } from \\"./MovieCreateNestedManyWithoutDirectorInput\\";
export { MovieCreateOrConnectWithoutDirectorInput } from \\"./MovieCreateOrConnectWithoutDirectorInput\\";
export { MovieCreateWithoutDirectorInput } from \\"./MovieCreateWithoutDirectorInput\\";
export { MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput } from \\"./MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput\\";
export { MovieListRelationFilter } from \\"./MovieListRelationFilter\\";
export { MovieOrderByInput } from \\"./MovieOrderByInput\\";
export { MovieScalarWhereInput } from \\"./MovieScalarWhereInput\\";
export { MovieScalarWhereWithAggregatesInput } from \\"./MovieScalarWhereWithAggregatesInput\\";
export { MovieUpdateInput } from \\"./MovieUpdateInput\\";
export { MovieUpdateManyMutationInput } from \\"./MovieUpdateManyMutationInput\\";
export { MovieUpdateManyWithWhereWithoutDirectorInput } from \\"./MovieUpdateManyWithWhereWithoutDirectorInput\\";
export { MovieUpdateManyWithoutDirectorInput } from \\"./MovieUpdateManyWithoutDirectorInput\\";
export { MovieUpdateWithWhereUniqueWithoutDirectorInput } from \\"./MovieUpdateWithWhereUniqueWithoutDirectorInput\\";
export { MovieUpdateWithoutDirectorInput } from \\"./MovieUpdateWithoutDirectorInput\\";
export { MovieUpsertWithWhereUniqueWithoutDirectorInput } from \\"./MovieUpsertWithWhereUniqueWithoutDirectorInput\\";
export { MovieWhereInput } from \\"./MovieWhereInput\\";
export { MovieWhereUniqueInput } from \\"./MovieWhereUniqueInput\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatWithAggregatesFilter } from \\"./NestedFloatWithAggregatesFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput {
  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  directorFirstName!: string;

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  directorLastName!: string;

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  title!: string;

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  get directorFirstName() {
    return this.directorFirstName;
  }

  set directorFirstName(directorFirstName: string) {
    this.directorFirstName = directorFirstName;
  }

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  get directorLastName() {
    return this.directorLastName;
  }

  set directorLastName(directorLastName: string) {
    this.directorLastName = directorLastName;
  }

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  get title() {
    return this.title;
  }

  set title(title: string) {
    this.title = title;
  }
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieOrderByInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class MovieOrderByInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  directorFirstName?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  directorLastName?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  title?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  rating?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get directorFirstName() {
    return this.directorFirstName;
  }

  set directorFirstName(directorFirstName: \\"asc\\" | \\"desc\\" | undefined) {
    this.directorFirstName = directorFirstName;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get directorLastName() {
    return this.directorLastName;
  }

  set directorLastName(directorLastName: \\"asc\\" | \\"desc\\" | undefined) {
    this.directorLastName = directorLastName;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get title() {
    return this.title;
  }

  set title(title: \\"asc\\" | \\"desc\\" | undefined) {
    this.title = title;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get rating() {
    return this.rating;
  }

  set rating(rating: \\"asc\\" | \\"desc\\" | undefined) {
    this.rating = rating;
  }
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieScalarWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class MovieScalarWhereInput {
  @TypeGraphQL.Field(_type => [MovieScalarWhereInput], {
    nullable: true
  })
  AND?: MovieScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [MovieScalarWhereInput], {
    nullable: true
  })
  OR?: MovieScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [MovieScalarWhereInput], {
    nullable: true
  })
  NOT?: MovieScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  directorFirstName?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  directorLastName?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  title?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  rating?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => [MovieScalarWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: MovieScalarWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [MovieScalarWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: MovieScalarWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [MovieScalarWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: MovieScalarWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get directorFirstName() {
    return this.directorFirstName;
  }

  set directorFirstName(directorFirstName: StringFilter | undefined) {
    this.directorFirstName = directorFirstName;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get directorLastName() {
    return this.directorLastName;
  }

  set directorLastName(directorLastName: StringFilter | undefined) {
    this.directorLastName = directorLastName;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get title() {
    return this.title;
  }

  set title(title: StringFilter | undefined) {
    this.title = title;
  }

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  get rating() {
    return this.rating;
  }

  set rating(rating: FloatFilter | undefined) {
    this.rating = rating;
  }
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { DirectorRelationFilter } from \\"../inputs/DirectorRelationFilter\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class MovieWhereInput {
  @TypeGraphQL.Field(_type => [MovieWhereInput], {
    nullable: true
  })
  AND?: MovieWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [MovieWhereInput], {
    nullable: true
  })
  OR?: MovieWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [MovieWhereInput], {
    nullable: true
  })
  NOT?: MovieWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  directorFirstName?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  directorLastName?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => DirectorRelationFilter, {
    nullable: true
  })
  director?: DirectorRelationFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  title?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  rating?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => [MovieWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: MovieWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [MovieWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: MovieWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [MovieWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: MovieWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get directorFirstName() {
    return this.directorFirstName;
  }

  set directorFirstName(directorFirstName: StringFilter | undefined) {
    this.directorFirstName = directorFirstName;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get directorLastName() {
    return this.directorLastName;
  }

  set directorLastName(directorLastName: StringFilter | undefined) {
    this.directorLastName = directorLastName;
  }

  @TypeGraphQL.Field(_type => DirectorRelationFilter, {
    nullable: true
  })
  get director() {
    return this.director;
  }

  set director(director: DirectorRelationFilter | undefined) {
    this.director = director;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get title() {
    return this.title;
  }

  set title(title: StringFilter | undefined) {
    this.title = title;
  }

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  get rating() {
    return this.rating;
  }

  set rating(rating: FloatFilter | undefined) {
    this.rating = rating;
  }
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput } from \\"../inputs/MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class MovieWhereUniqueInput {
  @TypeGraphQL.Field(_type => MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput, {
    nullable: true
  })
  directorFirstName_directorLastName_title?: MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput | undefined;

  @TypeGraphQL.Field(_type => MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput, {
    nullable: true
  })
  get directorFirstName_directorLastName_title() {
    return this.directorFirstName_directorLastName_title;
  }

  set directorFirstName_directorLastName_title(directorFirstName_directorLastName_title: MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput | undefined) {
    this.directorFirstName_directorLastName_title = directorFirstName_directorLastName_title;
  }
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: index 1`] = `
"export { DirectorCreateInput } from \\"./DirectorCreateInput\\";
export { DirectorCreateManyInput } from \\"./DirectorCreateManyInput\\";
export { DirectorCreateNestedOneWithoutMoviesInput } from \\"./DirectorCreateNestedOneWithoutMoviesInput\\";
export { DirectorCreateOrConnectWithoutMoviesInput } from \\"./DirectorCreateOrConnectWithoutMoviesInput\\";
export { DirectorCreateWithoutMoviesInput } from \\"./DirectorCreateWithoutMoviesInput\\";
export { DirectorFirstNameLastNameCompoundUniqueInput } from \\"./DirectorFirstNameLastNameCompoundUniqueInput\\";
export { DirectorOrderByInput } from \\"./DirectorOrderByInput\\";
export { DirectorRelationFilter } from \\"./DirectorRelationFilter\\";
export { DirectorScalarWhereWithAggregatesInput } from \\"./DirectorScalarWhereWithAggregatesInput\\";
export { DirectorUpdateInput } from \\"./DirectorUpdateInput\\";
export { DirectorUpdateManyMutationInput } from \\"./DirectorUpdateManyMutationInput\\";
export { DirectorUpdateOneRequiredWithoutMoviesInput } from \\"./DirectorUpdateOneRequiredWithoutMoviesInput\\";
export { DirectorUpdateWithoutMoviesInput } from \\"./DirectorUpdateWithoutMoviesInput\\";
export { DirectorUpsertWithoutMoviesInput } from \\"./DirectorUpsertWithoutMoviesInput\\";
export { DirectorWhereInput } from \\"./DirectorWhereInput\\";
export { DirectorWhereUniqueInput } from \\"./DirectorWhereUniqueInput\\";
export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { FloatWithAggregatesFilter } from \\"./FloatWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { MovieCreateInput } from \\"./MovieCreateInput\\";
export { MovieCreateManyDirectorInput } from \\"./MovieCreateManyDirectorInput\\";
export { MovieCreateManyDirectorInputEnvelope } from \\"./MovieCreateManyDirectorInputEnvelope\\";
export { MovieCreateManyInput } from \\"./MovieCreateManyInput\\";
export { MovieCreateNestedManyWithoutDirectorInput } from \\"./MovieCreateNestedManyWithoutDirectorInput\\";
export { MovieCreateOrConnectWithoutDirectorInput } from \\"./MovieCreateOrConnectWithoutDirectorInput\\";
export { MovieCreateWithoutDirectorInput } from \\"./MovieCreateWithoutDirectorInput\\";
export { MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput } from \\"./MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput\\";
export { MovieListRelationFilter } from \\"./MovieListRelationFilter\\";
export { MovieOrderByInput } from \\"./MovieOrderByInput\\";
export { MovieScalarWhereInput } from \\"./MovieScalarWhereInput\\";
export { MovieScalarWhereWithAggregatesInput } from \\"./MovieScalarWhereWithAggregatesInput\\";
export { MovieUpdateInput } from \\"./MovieUpdateInput\\";
export { MovieUpdateManyMutationInput } from \\"./MovieUpdateManyMutationInput\\";
export { MovieUpdateManyWithWhereWithoutDirectorInput } from \\"./MovieUpdateManyWithWhereWithoutDirectorInput\\";
export { MovieUpdateManyWithoutDirectorInput } from \\"./MovieUpdateManyWithoutDirectorInput\\";
export { MovieUpdateWithWhereUniqueWithoutDirectorInput } from \\"./MovieUpdateWithWhereUniqueWithoutDirectorInput\\";
export { MovieUpdateWithoutDirectorInput } from \\"./MovieUpdateWithoutDirectorInput\\";
export { MovieUpsertWithWhereUniqueWithoutDirectorInput } from \\"./MovieUpsertWithWhereUniqueWithoutDirectorInput\\";
export { MovieWhereInput } from \\"./MovieWhereInput\\";
export { MovieWhereUniqueInput } from \\"./MovieWhereUniqueInput\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatWithAggregatesFilter } from \\"./NestedFloatWithAggregatesFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for model with native types: NativeTypeModelCreateInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NativeTypeModelCreateInput {
  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  bigInt?: bigint | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.ByteResolver, {
    nullable: true
  })
  byteA?: Buffer | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  decimal?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  get bigInt() {
    return this.bigInt;
  }

  set bigInt(bigInt: bigint | undefined) {
    this.bigInt = bigInt;
  }

  @TypeGraphQL.Field(_type => GraphQLScalars.ByteResolver, {
    nullable: true
  })
  get byteA() {
    return this.byteA;
  }

  set byteA(byteA: Buffer | undefined) {
    this.byteA = byteA;
  }

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  get decimal() {
    return this.decimal;
  }

  set decimal(decimal: Prisma.Decimal | undefined) {
    this.decimal = decimal;
  }
}
"
`;

exports[`inputs should properly generate input type classes for model with native types: NativeTypeModelOrderByInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NativeTypeModelOrderByInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  id?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  bigInt?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  byteA?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  decimal?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get id() {
    return this.id;
  }

  set id(id: \\"asc\\" | \\"desc\\" | undefined) {
    this.id = id;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get bigInt() {
    return this.bigInt;
  }

  set bigInt(bigInt: \\"asc\\" | \\"desc\\" | undefined) {
    this.bigInt = bigInt;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get byteA() {
    return this.byteA;
  }

  set byteA(byteA: \\"asc\\" | \\"desc\\" | undefined) {
    this.byteA = byteA;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get decimal() {
    return this.decimal;
  }

  set decimal(decimal: \\"asc\\" | \\"desc\\" | undefined) {
    this.decimal = decimal;
  }
}
"
`;

exports[`inputs should properly generate input type classes for model with native types: NativeTypeModelUpdateInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NullableBigIntFieldUpdateOperationsInput } from \\"../inputs/NullableBigIntFieldUpdateOperationsInput\\";
import { NullableBytesFieldUpdateOperationsInput } from \\"../inputs/NullableBytesFieldUpdateOperationsInput\\";
import { NullableDecimalFieldUpdateOperationsInput } from \\"../inputs/NullableDecimalFieldUpdateOperationsInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NativeTypeModelUpdateInput {
  @TypeGraphQL.Field(_type => NullableBigIntFieldUpdateOperationsInput, {
    nullable: true
  })
  bigInt?: NullableBigIntFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableBytesFieldUpdateOperationsInput, {
    nullable: true
  })
  byteA?: NullableBytesFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableDecimalFieldUpdateOperationsInput, {
    nullable: true
  })
  decimal?: NullableDecimalFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableBigIntFieldUpdateOperationsInput, {
    nullable: true
  })
  get bigInt() {
    return this.bigInt;
  }

  set bigInt(bigInt: NullableBigIntFieldUpdateOperationsInput | undefined) {
    this.bigInt = bigInt;
  }

  @TypeGraphQL.Field(_type => NullableBytesFieldUpdateOperationsInput, {
    nullable: true
  })
  get byteA() {
    return this.byteA;
  }

  set byteA(byteA: NullableBytesFieldUpdateOperationsInput | undefined) {
    this.byteA = byteA;
  }

  @TypeGraphQL.Field(_type => NullableDecimalFieldUpdateOperationsInput, {
    nullable: true
  })
  get decimal() {
    return this.decimal;
  }

  set decimal(decimal: NullableDecimalFieldUpdateOperationsInput | undefined) {
    this.decimal = decimal;
  }
}
"
`;

exports[`inputs should properly generate input type classes for model with native types: NativeTypeModelUpdateManyMutationInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NullableBigIntFieldUpdateOperationsInput } from \\"../inputs/NullableBigIntFieldUpdateOperationsInput\\";
import { NullableBytesFieldUpdateOperationsInput } from \\"../inputs/NullableBytesFieldUpdateOperationsInput\\";
import { NullableDecimalFieldUpdateOperationsInput } from \\"../inputs/NullableDecimalFieldUpdateOperationsInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NativeTypeModelUpdateManyMutationInput {
  @TypeGraphQL.Field(_type => NullableBigIntFieldUpdateOperationsInput, {
    nullable: true
  })
  bigInt?: NullableBigIntFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableBytesFieldUpdateOperationsInput, {
    nullable: true
  })
  byteA?: NullableBytesFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableDecimalFieldUpdateOperationsInput, {
    nullable: true
  })
  decimal?: NullableDecimalFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableBigIntFieldUpdateOperationsInput, {
    nullable: true
  })
  get bigInt() {
    return this.bigInt;
  }

  set bigInt(bigInt: NullableBigIntFieldUpdateOperationsInput | undefined) {
    this.bigInt = bigInt;
  }

  @TypeGraphQL.Field(_type => NullableBytesFieldUpdateOperationsInput, {
    nullable: true
  })
  get byteA() {
    return this.byteA;
  }

  set byteA(byteA: NullableBytesFieldUpdateOperationsInput | undefined) {
    this.byteA = byteA;
  }

  @TypeGraphQL.Field(_type => NullableDecimalFieldUpdateOperationsInput, {
    nullable: true
  })
  get decimal() {
    return this.decimal;
  }

  set decimal(decimal: NullableDecimalFieldUpdateOperationsInput | undefined) {
    this.decimal = decimal;
  }
}
"
`;

exports[`inputs should properly generate input type classes for model with native types: NativeTypeModelWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { BigIntNullableFilter } from \\"../inputs/BigIntNullableFilter\\";
import { BytesNullableFilter } from \\"../inputs/BytesNullableFilter\\";
import { DecimalNullableFilter } from \\"../inputs/DecimalNullableFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NativeTypeModelWhereInput {
  @TypeGraphQL.Field(_type => [NativeTypeModelWhereInput], {
    nullable: true
  })
  AND?: NativeTypeModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [NativeTypeModelWhereInput], {
    nullable: true
  })
  OR?: NativeTypeModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [NativeTypeModelWhereInput], {
    nullable: true
  })
  NOT?: NativeTypeModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  id?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => BigIntNullableFilter, {
    nullable: true
  })
  bigInt?: BigIntNullableFilter | undefined;

  @TypeGraphQL.Field(_type => BytesNullableFilter, {
    nullable: true
  })
  byteA?: BytesNullableFilter | undefined;

  @TypeGraphQL.Field(_type => DecimalNullableFilter, {
    nullable: true
  })
  decimal?: DecimalNullableFilter | undefined;

  @TypeGraphQL.Field(_type => [NativeTypeModelWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: NativeTypeModelWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [NativeTypeModelWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: NativeTypeModelWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [NativeTypeModelWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: NativeTypeModelWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get id() {
    return this.id;
  }

  set id(id: IntFilter | undefined) {
    this.id = id;
  }

  @TypeGraphQL.Field(_type => BigIntNullableFilter, {
    nullable: true
  })
  get bigInt() {
    return this.bigInt;
  }

  set bigInt(bigInt: BigIntNullableFilter | undefined) {
    this.bigInt = bigInt;
  }

  @TypeGraphQL.Field(_type => BytesNullableFilter, {
    nullable: true
  })
  get byteA() {
    return this.byteA;
  }

  set byteA(byteA: BytesNullableFilter | undefined) {
    this.byteA = byteA;
  }

  @TypeGraphQL.Field(_type => DecimalNullableFilter, {
    nullable: true
  })
  get decimal() {
    return this.decimal;
  }

  set decimal(decimal: DecimalNullableFilter | undefined) {
    this.decimal = decimal;
  }
}
"
`;

exports[`inputs should properly generate input type classes for model with native types: NativeTypeModelWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NativeTypeModelWhereUniqueInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  id?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get id() {
    return this.id;
  }

  set id(id: number | undefined) {
    this.id = id;
  }
}
"
`;

exports[`inputs should properly generate input type classes for model with native types: index 1`] = `
"export { BigIntNullableFilter } from \\"./BigIntNullableFilter\\";
export { BigIntNullableWithAggregatesFilter } from \\"./BigIntNullableWithAggregatesFilter\\";
export { BytesNullableFilter } from \\"./BytesNullableFilter\\";
export { BytesNullableWithAggregatesFilter } from \\"./BytesNullableWithAggregatesFilter\\";
export { DecimalNullableFilter } from \\"./DecimalNullableFilter\\";
export { DecimalNullableWithAggregatesFilter } from \\"./DecimalNullableWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { NativeTypeModelCreateInput } from \\"./NativeTypeModelCreateInput\\";
export { NativeTypeModelCreateManyInput } from \\"./NativeTypeModelCreateManyInput\\";
export { NativeTypeModelOrderByInput } from \\"./NativeTypeModelOrderByInput\\";
export { NativeTypeModelScalarWhereWithAggregatesInput } from \\"./NativeTypeModelScalarWhereWithAggregatesInput\\";
export { NativeTypeModelUpdateInput } from \\"./NativeTypeModelUpdateInput\\";
export { NativeTypeModelUpdateManyMutationInput } from \\"./NativeTypeModelUpdateManyMutationInput\\";
export { NativeTypeModelWhereInput } from \\"./NativeTypeModelWhereInput\\";
export { NativeTypeModelWhereUniqueInput } from \\"./NativeTypeModelWhereUniqueInput\\";
export { NestedBigIntNullableFilter } from \\"./NestedBigIntNullableFilter\\";
export { NestedBigIntNullableWithAggregatesFilter } from \\"./NestedBigIntNullableWithAggregatesFilter\\";
export { NestedBytesNullableFilter } from \\"./NestedBytesNullableFilter\\";
export { NestedBytesNullableWithAggregatesFilter } from \\"./NestedBytesNullableWithAggregatesFilter\\";
export { NestedDecimalNullableFilter } from \\"./NestedDecimalNullableFilter\\";
export { NestedDecimalNullableWithAggregatesFilter } from \\"./NestedDecimalNullableWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatNullableFilter } from \\"./NestedFloatNullableFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntNullableFilter } from \\"./NestedIntNullableFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NullableBigIntFieldUpdateOperationsInput } from \\"./NullableBigIntFieldUpdateOperationsInput\\";
export { NullableBytesFieldUpdateOperationsInput } from \\"./NullableBytesFieldUpdateOperationsInput\\";
export { NullableDecimalFieldUpdateOperationsInput } from \\"./NullableDecimalFieldUpdateOperationsInput\\";
"
`;

exports[`inputs should properly generate input type classes for omitted fields: SampleModelWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { BoolFilter } from \\"../inputs/BoolFilter\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleModelWhereInput {
  @TypeGraphQL.Field(_type => [SampleModelWhereInput], {
    nullable: true
  })
  AND?: SampleModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleModelWhereInput], {
    nullable: true
  })
  OR?: SampleModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleModelWhereInput], {
    nullable: true
  })
  NOT?: SampleModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  intIdField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  stringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => [SampleModelWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: SampleModelWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [SampleModelWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: SampleModelWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [SampleModelWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: SampleModelWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get intIdField() {
    return this.intIdField;
  }

  set intIdField(intIdField: IntFilter | undefined) {
    this.intIdField = intIdField;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get stringField() {
    return this.stringField;
  }

  set stringField(stringField: StringFilter | undefined) {
    this.stringField = stringField;
  }

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFilter | undefined) {
    this.floatField = floatField;
  }
}
"
`;

exports[`inputs should properly generate input type classes for omitted fields: SampleModelWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleModelWhereUniqueInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  intIdField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  stringField?: string | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get intIdField() {
    return this.intIdField;
  }

  set intIdField(intIdField: number | undefined) {
    this.intIdField = intIdField;
  }

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  get stringField() {
    return this.stringField;
  }

  set stringField(stringField: string | undefined) {
    this.stringField = stringField;
  }
}
"
`;

exports[`inputs should properly generate input type classes for omitted fields: index 1`] = `
"export { BoolFieldUpdateOperationsInput } from \\"./BoolFieldUpdateOperationsInput\\";
export { BoolFilter } from \\"./BoolFilter\\";
export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { NestedBoolFilter } from \\"./NestedBoolFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { SampleModelCreateInput } from \\"./SampleModelCreateInput\\";
export { SampleModelOrderByInput } from \\"./SampleModelOrderByInput\\";
export { SampleModelUpdateInput } from \\"./SampleModelUpdateInput\\";
export { SampleModelUpdateManyMutationInput } from \\"./SampleModelUpdateManyMutationInput\\";
export { SampleModelWhereInput } from \\"./SampleModelWhereInput\\";
export { SampleModelWhereUniqueInput } from \\"./SampleModelWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: BoolFieldUpdateOperationsInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class BoolFieldUpdateOperationsInput {
  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  set?: boolean | undefined;

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  get set() {
    return this.set;
  }

  set set(set: boolean | undefined) {
    this.set = set;
  }
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: DateTimeFieldUpdateOperationsInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class DateTimeFieldUpdateOperationsInput {
  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  set?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  get set() {
    return this.set;
  }

  set set(set: Date | undefined) {
    this.set = set;
  }
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: EnumColorFieldUpdateOperationsInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { Color } from \\"../../enums/Color\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class EnumColorFieldUpdateOperationsInput {
  @TypeGraphQL.Field(_type => Color, {
    nullable: true
  })
  set?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @TypeGraphQL.Field(_type => Color, {
    nullable: true
  })
  get set() {
    return this.set;
  }

  set set(set: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined) {
    this.set = set;
  }
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: FloatFieldUpdateOperationsInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FloatFieldUpdateOperationsInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  set?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  increment?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  decrement?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  multiply?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  divide?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  get set() {
    return this.set;
  }

  set set(set: number | undefined) {
    this.set = set;
  }

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  get increment() {
    return this.increment;
  }

  set increment(increment: number | undefined) {
    this.increment = increment;
  }

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  get decrement() {
    return this.decrement;
  }

  set decrement(decrement: number | undefined) {
    this.decrement = decrement;
  }

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  get multiply() {
    return this.multiply;
  }

  set multiply(multiply: number | undefined) {
    this.multiply = multiply;
  }

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  get divide() {
    return this.divide;
  }

  set divide(divide: number | undefined) {
    this.divide = divide;
  }
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: IntFieldUpdateOperationsInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class IntFieldUpdateOperationsInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  set?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  increment?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  decrement?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  multiply?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  divide?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get set() {
    return this.set;
  }

  set set(set: number | undefined) {
    this.set = set;
  }

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get increment() {
    return this.increment;
  }

  set increment(increment: number | undefined) {
    this.increment = increment;
  }

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get decrement() {
    return this.decrement;
  }

  set decrement(decrement: number | undefined) {
    this.decrement = decrement;
  }

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get multiply() {
    return this.multiply;
  }

  set multiply(multiply: number | undefined) {
    this.multiply = multiply;
  }

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get divide() {
    return this.divide;
  }

  set divide(divide: number | undefined) {
    this.divide = divide;
  }
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: SampleModelUpdateInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { BoolFieldUpdateOperationsInput } from \\"../inputs/BoolFieldUpdateOperationsInput\\";
import { DateTimeFieldUpdateOperationsInput } from \\"../inputs/DateTimeFieldUpdateOperationsInput\\";
import { EnumColorFieldUpdateOperationsInput } from \\"../inputs/EnumColorFieldUpdateOperationsInput\\";
import { FloatFieldUpdateOperationsInput } from \\"../inputs/FloatFieldUpdateOperationsInput\\";
import { IntFieldUpdateOperationsInput } from \\"../inputs/IntFieldUpdateOperationsInput\\";
import { NullableBoolFieldUpdateOperationsInput } from \\"../inputs/NullableBoolFieldUpdateOperationsInput\\";
import { NullableDateTimeFieldUpdateOperationsInput } from \\"../inputs/NullableDateTimeFieldUpdateOperationsInput\\";
import { NullableEnumColorFieldUpdateOperationsInput } from \\"../inputs/NullableEnumColorFieldUpdateOperationsInput\\";
import { NullableFloatFieldUpdateOperationsInput } from \\"../inputs/NullableFloatFieldUpdateOperationsInput\\";
import { NullableIntFieldUpdateOperationsInput } from \\"../inputs/NullableIntFieldUpdateOperationsInput\\";
import { NullableStringFieldUpdateOperationsInput } from \\"../inputs/NullableStringFieldUpdateOperationsInput\\";
import { SampleModelUpdateintArrayFieldInput } from \\"../inputs/SampleModelUpdateintArrayFieldInput\\";
import { SampleModelUpdatestringArrayFieldInput } from \\"../inputs/SampleModelUpdatestringArrayFieldInput\\";
import { StringFieldUpdateOperationsInput } from \\"../inputs/StringFieldUpdateOperationsInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleModelUpdateInput {
  @TypeGraphQL.Field(_type => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  stringField?: StringFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableStringFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalStringField?: NullableStringFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => IntFieldUpdateOperationsInput, {
    nullable: true
  })
  intField?: IntFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableIntFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalIntField?: NullableIntFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  floatField?: FloatFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableFloatFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalFloatField?: NullableFloatFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => BoolFieldUpdateOperationsInput, {
    nullable: true
  })
  booleanField?: BoolFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableBoolFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalBooleanField?: NullableBoolFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => DateTimeFieldUpdateOperationsInput, {
    nullable: true
  })
  dateField?: DateTimeFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableDateTimeFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalDateField?: NullableDateTimeFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  jsonField?: Prisma.InputJsonValue | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  optionalJsonField?: Prisma.InputJsonValue | undefined;

  @TypeGraphQL.Field(_type => EnumColorFieldUpdateOperationsInput, {
    nullable: true
  })
  enumField?: EnumColorFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableEnumColorFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalEnumField?: NullableEnumColorFieldUpdateOperationsInput | undefined;

<<<<<<< HEAD
  @TypeGraphQL.Field(_type => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  get stringField() {
    return this.stringField;
  }

  set stringField(stringField: StringFieldUpdateOperationsInput | undefined) {
    this.stringField = stringField;
  }

  @TypeGraphQL.Field(_type => NullableStringFieldUpdateOperationsInput, {
    nullable: true
  })
  get optionalStringField() {
    return this.optionalStringField;
  }

  set optionalStringField(optionalStringField: NullableStringFieldUpdateOperationsInput | undefined) {
    this.optionalStringField = optionalStringField;
  }

  @TypeGraphQL.Field(_type => IntFieldUpdateOperationsInput, {
    nullable: true
  })
  get intField() {
    return this.intField;
  }

  set intField(intField: IntFieldUpdateOperationsInput | undefined) {
    this.intField = intField;
  }

  @TypeGraphQL.Field(_type => NullableIntFieldUpdateOperationsInput, {
    nullable: true
  })
  get optionalIntField() {
    return this.optionalIntField;
  }

  set optionalIntField(optionalIntField: NullableIntFieldUpdateOperationsInput | undefined) {
    this.optionalIntField = optionalIntField;
  }

  @TypeGraphQL.Field(_type => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFieldUpdateOperationsInput | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => NullableFloatFieldUpdateOperationsInput, {
    nullable: true
  })
  get optionalFloatField() {
    return this.optionalFloatField;
  }

  set optionalFloatField(optionalFloatField: NullableFloatFieldUpdateOperationsInput | undefined) {
    this.optionalFloatField = optionalFloatField;
  }

  @TypeGraphQL.Field(_type => BoolFieldUpdateOperationsInput, {
    nullable: true
  })
  get booleanField() {
    return this.booleanField;
  }

  set booleanField(booleanField: BoolFieldUpdateOperationsInput | undefined) {
    this.booleanField = booleanField;
  }

  @TypeGraphQL.Field(_type => NullableBoolFieldUpdateOperationsInput, {
    nullable: true
  })
  get optionalBooleanField() {
    return this.optionalBooleanField;
  }

  set optionalBooleanField(optionalBooleanField: NullableBoolFieldUpdateOperationsInput | undefined) {
    this.optionalBooleanField = optionalBooleanField;
  }

  @TypeGraphQL.Field(_type => DateTimeFieldUpdateOperationsInput, {
    nullable: true
  })
  get dateField() {
    return this.dateField;
  }

  set dateField(dateField: DateTimeFieldUpdateOperationsInput | undefined) {
    this.dateField = dateField;
  }

  @TypeGraphQL.Field(_type => NullableDateTimeFieldUpdateOperationsInput, {
    nullable: true
  })
  get optionalDateField() {
    return this.optionalDateField;
  }

  set optionalDateField(optionalDateField: NullableDateTimeFieldUpdateOperationsInput | undefined) {
    this.optionalDateField = optionalDateField;
  }

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  get jsonField() {
    return this.jsonField;
  }

  set jsonField(jsonField: Prisma.InputJsonValue | undefined) {
    this.jsonField = jsonField;
  }

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  get optionalJsonField() {
    return this.optionalJsonField;
  }

  set optionalJsonField(optionalJsonField: Prisma.InputJsonValue | undefined) {
    this.optionalJsonField = optionalJsonField;
  }

  @TypeGraphQL.Field(_type => EnumColorFieldUpdateOperationsInput, {
    nullable: true
  })
  get enumField() {
    return this.enumField;
  }

  set enumField(enumField: EnumColorFieldUpdateOperationsInput | undefined) {
    this.enumField = enumField;
  }

  @TypeGraphQL.Field(_type => NullableEnumColorFieldUpdateOperationsInput, {
    nullable: true
  })
  get optionalEnumField() {
    return this.optionalEnumField;
  }

  set optionalEnumField(optionalEnumField: NullableEnumColorFieldUpdateOperationsInput | undefined) {
    this.optionalEnumField = optionalEnumField;
  }
=======
  @TypeGraphQL.Field(_type => SampleModelUpdateintArrayFieldInput, {
    nullable: true
  })
  intArrayField?: SampleModelUpdateintArrayFieldInput | undefined;

  @TypeGraphQL.Field(_type => SampleModelUpdatestringArrayFieldInput, {
    nullable: true
  })
  stringArrayField?: SampleModelUpdatestringArrayFieldInput | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: SampleModelUpdateManyMutationInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { BoolFieldUpdateOperationsInput } from \\"../inputs/BoolFieldUpdateOperationsInput\\";
import { DateTimeFieldUpdateOperationsInput } from \\"../inputs/DateTimeFieldUpdateOperationsInput\\";
import { EnumColorFieldUpdateOperationsInput } from \\"../inputs/EnumColorFieldUpdateOperationsInput\\";
import { FloatFieldUpdateOperationsInput } from \\"../inputs/FloatFieldUpdateOperationsInput\\";
import { IntFieldUpdateOperationsInput } from \\"../inputs/IntFieldUpdateOperationsInput\\";
import { NullableBoolFieldUpdateOperationsInput } from \\"../inputs/NullableBoolFieldUpdateOperationsInput\\";
import { NullableDateTimeFieldUpdateOperationsInput } from \\"../inputs/NullableDateTimeFieldUpdateOperationsInput\\";
import { NullableEnumColorFieldUpdateOperationsInput } from \\"../inputs/NullableEnumColorFieldUpdateOperationsInput\\";
import { NullableFloatFieldUpdateOperationsInput } from \\"../inputs/NullableFloatFieldUpdateOperationsInput\\";
import { NullableIntFieldUpdateOperationsInput } from \\"../inputs/NullableIntFieldUpdateOperationsInput\\";
import { NullableStringFieldUpdateOperationsInput } from \\"../inputs/NullableStringFieldUpdateOperationsInput\\";
import { SampleModelUpdateintArrayFieldInput } from \\"../inputs/SampleModelUpdateintArrayFieldInput\\";
import { SampleModelUpdatestringArrayFieldInput } from \\"../inputs/SampleModelUpdatestringArrayFieldInput\\";
import { StringFieldUpdateOperationsInput } from \\"../inputs/StringFieldUpdateOperationsInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleModelUpdateManyMutationInput {
  @TypeGraphQL.Field(_type => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  stringField?: StringFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableStringFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalStringField?: NullableStringFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => IntFieldUpdateOperationsInput, {
    nullable: true
  })
  intField?: IntFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableIntFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalIntField?: NullableIntFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  floatField?: FloatFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableFloatFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalFloatField?: NullableFloatFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => BoolFieldUpdateOperationsInput, {
    nullable: true
  })
  booleanField?: BoolFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableBoolFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalBooleanField?: NullableBoolFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => DateTimeFieldUpdateOperationsInput, {
    nullable: true
  })
  dateField?: DateTimeFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableDateTimeFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalDateField?: NullableDateTimeFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  jsonField?: Prisma.InputJsonValue | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  optionalJsonField?: Prisma.InputJsonValue | undefined;

  @TypeGraphQL.Field(_type => EnumColorFieldUpdateOperationsInput, {
    nullable: true
  })
  enumField?: EnumColorFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => NullableEnumColorFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalEnumField?: NullableEnumColorFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  get stringField() {
    return this.stringField;
  }

  set stringField(stringField: StringFieldUpdateOperationsInput | undefined) {
    this.stringField = stringField;
  }

  @TypeGraphQL.Field(_type => NullableStringFieldUpdateOperationsInput, {
    nullable: true
  })
  get optionalStringField() {
    return this.optionalStringField;
  }

  set optionalStringField(optionalStringField: NullableStringFieldUpdateOperationsInput | undefined) {
    this.optionalStringField = optionalStringField;
  }

  @TypeGraphQL.Field(_type => IntFieldUpdateOperationsInput, {
    nullable: true
  })
  get intField() {
    return this.intField;
  }

  set intField(intField: IntFieldUpdateOperationsInput | undefined) {
    this.intField = intField;
  }

  @TypeGraphQL.Field(_type => NullableIntFieldUpdateOperationsInput, {
    nullable: true
  })
  get optionalIntField() {
    return this.optionalIntField;
  }

  set optionalIntField(optionalIntField: NullableIntFieldUpdateOperationsInput | undefined) {
    this.optionalIntField = optionalIntField;
  }

  @TypeGraphQL.Field(_type => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFieldUpdateOperationsInput | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => NullableFloatFieldUpdateOperationsInput, {
    nullable: true
  })
  get optionalFloatField() {
    return this.optionalFloatField;
  }

  set optionalFloatField(optionalFloatField: NullableFloatFieldUpdateOperationsInput | undefined) {
    this.optionalFloatField = optionalFloatField;
  }

  @TypeGraphQL.Field(_type => BoolFieldUpdateOperationsInput, {
    nullable: true
  })
  get booleanField() {
    return this.booleanField;
  }

  set booleanField(booleanField: BoolFieldUpdateOperationsInput | undefined) {
    this.booleanField = booleanField;
  }

  @TypeGraphQL.Field(_type => NullableBoolFieldUpdateOperationsInput, {
    nullable: true
  })
  get optionalBooleanField() {
    return this.optionalBooleanField;
  }

  set optionalBooleanField(optionalBooleanField: NullableBoolFieldUpdateOperationsInput | undefined) {
    this.optionalBooleanField = optionalBooleanField;
  }

  @TypeGraphQL.Field(_type => DateTimeFieldUpdateOperationsInput, {
    nullable: true
  })
  get dateField() {
    return this.dateField;
  }

  set dateField(dateField: DateTimeFieldUpdateOperationsInput | undefined) {
    this.dateField = dateField;
  }

  @TypeGraphQL.Field(_type => NullableDateTimeFieldUpdateOperationsInput, {
    nullable: true
  })
  get optionalDateField() {
    return this.optionalDateField;
  }

  set optionalDateField(optionalDateField: NullableDateTimeFieldUpdateOperationsInput | undefined) {
    this.optionalDateField = optionalDateField;
  }

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  get jsonField() {
    return this.jsonField;
  }

  set jsonField(jsonField: Prisma.InputJsonValue | undefined) {
    this.jsonField = jsonField;
  }

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  get optionalJsonField() {
    return this.optionalJsonField;
  }

  set optionalJsonField(optionalJsonField: Prisma.InputJsonValue | undefined) {
    this.optionalJsonField = optionalJsonField;
  }

  @TypeGraphQL.Field(_type => EnumColorFieldUpdateOperationsInput, {
    nullable: true
  })
  get enumField() {
    return this.enumField;
  }

  set enumField(enumField: EnumColorFieldUpdateOperationsInput | undefined) {
    this.enumField = enumField;
  }

  @TypeGraphQL.Field(_type => NullableEnumColorFieldUpdateOperationsInput, {
    nullable: true
  })
<<<<<<< HEAD
  get optionalEnumField() {
    return this.optionalEnumField;
  }

  set optionalEnumField(optionalEnumField: NullableEnumColorFieldUpdateOperationsInput | undefined) {
    this.optionalEnumField = optionalEnumField;
  }
=======
  optionalEnumField?: NullableEnumColorFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => SampleModelUpdateintArrayFieldInput, {
    nullable: true
  })
  intArrayField?: SampleModelUpdateintArrayFieldInput | undefined;

  @TypeGraphQL.Field(_type => SampleModelUpdatestringArrayFieldInput, {
    nullable: true
  })
  stringArrayField?: SampleModelUpdatestringArrayFieldInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: SampleModelUpdateintArrayFieldInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleModelUpdateintArrayFieldInput {
  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true
  })
  set?: number[] | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true
  })
  push?: number[] | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: SampleModelUpdatestringArrayFieldInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleModelUpdatestringArrayFieldInput {
  @TypeGraphQL.Field(_type => [String], {
    nullable: true
  })
  set?: string[] | undefined;

  @TypeGraphQL.Field(_type => [String], {
    nullable: true
  })
  push?: string[] | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: StringFieldUpdateOperationsInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class StringFieldUpdateOperationsInput {
  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  set?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  get set() {
    return this.set;
  }

  set set(set: string | undefined) {
    this.set = set;
  }
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: index 1`] = `
"export { BoolFieldUpdateOperationsInput } from \\"./BoolFieldUpdateOperationsInput\\";
export { BoolFilter } from \\"./BoolFilter\\";
export { BoolNullableFilter } from \\"./BoolNullableFilter\\";
export { BoolNullableWithAggregatesFilter } from \\"./BoolNullableWithAggregatesFilter\\";
export { BoolWithAggregatesFilter } from \\"./BoolWithAggregatesFilter\\";
export { DateTimeFieldUpdateOperationsInput } from \\"./DateTimeFieldUpdateOperationsInput\\";
export { DateTimeFilter } from \\"./DateTimeFilter\\";
export { DateTimeNullableFilter } from \\"./DateTimeNullableFilter\\";
export { DateTimeNullableWithAggregatesFilter } from \\"./DateTimeNullableWithAggregatesFilter\\";
export { DateTimeWithAggregatesFilter } from \\"./DateTimeWithAggregatesFilter\\";
export { EnumColorFieldUpdateOperationsInput } from \\"./EnumColorFieldUpdateOperationsInput\\";
export { EnumColorFilter } from \\"./EnumColorFilter\\";
export { EnumColorNullableFilter } from \\"./EnumColorNullableFilter\\";
export { EnumColorNullableWithAggregatesFilter } from \\"./EnumColorNullableWithAggregatesFilter\\";
export { EnumColorWithAggregatesFilter } from \\"./EnumColorWithAggregatesFilter\\";
export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { FloatNullableFilter } from \\"./FloatNullableFilter\\";
export { FloatNullableWithAggregatesFilter } from \\"./FloatNullableWithAggregatesFilter\\";
export { FloatWithAggregatesFilter } from \\"./FloatWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntNullableFilter } from \\"./IntNullableFilter\\";
export { IntNullableListFilter } from \\"./IntNullableListFilter\\";
export { IntNullableWithAggregatesFilter } from \\"./IntNullableWithAggregatesFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { JsonFilter } from \\"./JsonFilter\\";
export { JsonNullableFilter } from \\"./JsonNullableFilter\\";
export { JsonNullableWithAggregatesFilter } from \\"./JsonNullableWithAggregatesFilter\\";
export { JsonWithAggregatesFilter } from \\"./JsonWithAggregatesFilter\\";
export { NestedBoolFilter } from \\"./NestedBoolFilter\\";
export { NestedBoolNullableFilter } from \\"./NestedBoolNullableFilter\\";
export { NestedBoolNullableWithAggregatesFilter } from \\"./NestedBoolNullableWithAggregatesFilter\\";
export { NestedBoolWithAggregatesFilter } from \\"./NestedBoolWithAggregatesFilter\\";
export { NestedDateTimeFilter } from \\"./NestedDateTimeFilter\\";
export { NestedDateTimeNullableFilter } from \\"./NestedDateTimeNullableFilter\\";
export { NestedDateTimeNullableWithAggregatesFilter } from \\"./NestedDateTimeNullableWithAggregatesFilter\\";
export { NestedDateTimeWithAggregatesFilter } from \\"./NestedDateTimeWithAggregatesFilter\\";
export { NestedEnumColorFilter } from \\"./NestedEnumColorFilter\\";
export { NestedEnumColorNullableFilter } from \\"./NestedEnumColorNullableFilter\\";
export { NestedEnumColorNullableWithAggregatesFilter } from \\"./NestedEnumColorNullableWithAggregatesFilter\\";
export { NestedEnumColorWithAggregatesFilter } from \\"./NestedEnumColorWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatNullableFilter } from \\"./NestedFloatNullableFilter\\";
export { NestedFloatNullableWithAggregatesFilter } from \\"./NestedFloatNullableWithAggregatesFilter\\";
export { NestedFloatWithAggregatesFilter } from \\"./NestedFloatWithAggregatesFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntNullableFilter } from \\"./NestedIntNullableFilter\\";
export { NestedIntNullableWithAggregatesFilter } from \\"./NestedIntNullableWithAggregatesFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedJsonFilter } from \\"./NestedJsonFilter\\";
export { NestedJsonNullableFilter } from \\"./NestedJsonNullableFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringNullableFilter } from \\"./NestedStringNullableFilter\\";
export { NestedStringNullableWithAggregatesFilter } from \\"./NestedStringNullableWithAggregatesFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { NullableBoolFieldUpdateOperationsInput } from \\"./NullableBoolFieldUpdateOperationsInput\\";
export { NullableDateTimeFieldUpdateOperationsInput } from \\"./NullableDateTimeFieldUpdateOperationsInput\\";
export { NullableEnumColorFieldUpdateOperationsInput } from \\"./NullableEnumColorFieldUpdateOperationsInput\\";
export { NullableFloatFieldUpdateOperationsInput } from \\"./NullableFloatFieldUpdateOperationsInput\\";
export { NullableIntFieldUpdateOperationsInput } from \\"./NullableIntFieldUpdateOperationsInput\\";
export { NullableStringFieldUpdateOperationsInput } from \\"./NullableStringFieldUpdateOperationsInput\\";
export { SampleModelCreateInput } from \\"./SampleModelCreateInput\\";
export { SampleModelCreateManyInput } from \\"./SampleModelCreateManyInput\\";
export { SampleModelCreateManyintArrayFieldInput } from \\"./SampleModelCreateManyintArrayFieldInput\\";
export { SampleModelCreateManystringArrayFieldInput } from \\"./SampleModelCreateManystringArrayFieldInput\\";
export { SampleModelCreateintArrayFieldInput } from \\"./SampleModelCreateintArrayFieldInput\\";
export { SampleModelCreatestringArrayFieldInput } from \\"./SampleModelCreatestringArrayFieldInput\\";
export { SampleModelOrderByInput } from \\"./SampleModelOrderByInput\\";
export { SampleModelScalarWhereWithAggregatesInput } from \\"./SampleModelScalarWhereWithAggregatesInput\\";
export { SampleModelUpdateInput } from \\"./SampleModelUpdateInput\\";
export { SampleModelUpdateManyMutationInput } from \\"./SampleModelUpdateManyMutationInput\\";
export { SampleModelUpdateintArrayFieldInput } from \\"./SampleModelUpdateintArrayFieldInput\\";
export { SampleModelUpdatestringArrayFieldInput } from \\"./SampleModelUpdatestringArrayFieldInput\\";
export { SampleModelWhereInput } from \\"./SampleModelWhereInput\\";
export { SampleModelWhereUniqueInput } from \\"./SampleModelWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringNullableFilter } from \\"./StringNullableFilter\\";
export { StringNullableListFilter } from \\"./StringNullableListFilter\\";
export { StringNullableWithAggregatesFilter } from \\"./StringNullableWithAggregatesFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: BigIntNullableFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedBigIntNullableFilter } from \\"../inputs/NestedBigIntNullableFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class BigIntNullableFilter {
  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  equals?: bigint | undefined;

  @TypeGraphQL.Field(_type => [GraphQLScalars.BigIntResolver], {
    nullable: true
  })
  in?: bigint[] | undefined;

  @TypeGraphQL.Field(_type => [GraphQLScalars.BigIntResolver], {
    nullable: true
  })
  notIn?: bigint[] | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  lt?: bigint | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  lte?: bigint | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  gt?: bigint | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  gte?: bigint | undefined;

  @TypeGraphQL.Field(_type => NestedBigIntNullableFilter, {
    nullable: true
  })
  not?: NestedBigIntNullableFilter | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: bigint | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [GraphQLScalars.BigIntResolver], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: bigint[] | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [GraphQLScalars.BigIntResolver], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: bigint[] | undefined) {
  this.notIn = notIn;
}

@TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
  nullable: true
})
get lt() {
  return this.lt;
}

set lt(lt: bigint | undefined) {
  this.lt = lt;
}

@TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
  nullable: true
})
get lte() {
  return this.lte;
}

set lte(lte: bigint | undefined) {
  this.lte = lte;
}

@TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
  nullable: true
})
get gt() {
  return this.gt;
}

set gt(gt: bigint | undefined) {
  this.gt = gt;
}

@TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
  nullable: true
})
get gte() {
  return this.gte;
}

set gte(gte: bigint | undefined) {
  this.gte = gte;
}

@TypeGraphQL.Field(_type => NestedBigIntNullableFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedBigIntNullableFilter | undefined) {
  this.not = not;
}
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: BigIntNullableWithAggregatesFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedBigIntNullableFilter } from \\"../inputs/NestedBigIntNullableFilter\\";
import { NestedBigIntNullableWithAggregatesFilter } from \\"../inputs/NestedBigIntNullableWithAggregatesFilter\\";
import { NestedFloatNullableFilter } from \\"../inputs/NestedFloatNullableFilter\\";
import { NestedIntNullableFilter } from \\"../inputs/NestedIntNullableFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class BigIntNullableWithAggregatesFilter {
  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  equals?: bigint | undefined;

  @TypeGraphQL.Field(_type => [GraphQLScalars.BigIntResolver], {
    nullable: true
  })
  in?: bigint[] | undefined;

  @TypeGraphQL.Field(_type => [GraphQLScalars.BigIntResolver], {
    nullable: true
  })
  notIn?: bigint[] | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  lt?: bigint | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  lte?: bigint | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  gt?: bigint | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  gte?: bigint | undefined;

  @TypeGraphQL.Field(_type => NestedBigIntNullableWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedBigIntNullableWithAggregatesFilter | undefined;

  @TypeGraphQL.Field(_type => NestedIntNullableFilter, {
    nullable: true
  })
  _count?: NestedIntNullableFilter | undefined;

  @TypeGraphQL.Field(_type => NestedFloatNullableFilter, {
    nullable: true
  })
  _avg?: NestedFloatNullableFilter | undefined;

  @TypeGraphQL.Field(_type => NestedBigIntNullableFilter, {
    nullable: true
  })
  _sum?: NestedBigIntNullableFilter | undefined;

  @TypeGraphQL.Field(_type => NestedBigIntNullableFilter, {
    nullable: true
  })
  _min?: NestedBigIntNullableFilter | undefined;

  @TypeGraphQL.Field(_type => NestedBigIntNullableFilter, {
    nullable: true
  })
  _max?: NestedBigIntNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: BytesNullableFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedBytesNullableFilter } from \\"../inputs/NestedBytesNullableFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class BytesNullableFilter {
  @TypeGraphQL.Field(_type => GraphQLScalars.ByteResolver, {
    nullable: true
  })
  equals?: Buffer | undefined;

  @TypeGraphQL.Field(_type => NestedBytesNullableFilter, {
    nullable: true
  })
  not?: NestedBytesNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: BytesNullableWithAggregatesFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedBytesNullableFilter } from \\"../inputs/NestedBytesNullableFilter\\";
import { NestedBytesNullableWithAggregatesFilter } from \\"../inputs/NestedBytesNullableWithAggregatesFilter\\";
import { NestedIntNullableFilter } from \\"../inputs/NestedIntNullableFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class BytesNullableWithAggregatesFilter {
  @TypeGraphQL.Field(_type => GraphQLScalars.ByteResolver, {
    nullable: true
  })
  equals?: Buffer | undefined;

  @TypeGraphQL.Field(_type => NestedBytesNullableWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedBytesNullableWithAggregatesFilter | undefined;

  @TypeGraphQL.Field(_type => NestedIntNullableFilter, {
    nullable: true
  })
  _count?: NestedIntNullableFilter | undefined;

  @TypeGraphQL.Field(_type => NestedBytesNullableFilter, {
    nullable: true
  })
  _min?: NestedBytesNullableFilter | undefined;

  @TypeGraphQL.Field(_type => NestedBytesNullableFilter, {
    nullable: true
  })
<<<<<<< HEAD
  not?: NestedBytesNullableFilter | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.ByteResolver, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: Buffer | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => NestedBytesNullableFilter, {
    nullable: true
  })
  get not() {
    return this.not;
  }

  set not(not: NestedBytesNullableFilter | undefined) {
    this.not = not;
  }
=======
  _max?: NestedBytesNullableFilter | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: DecimalNullableFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedDecimalNullableFilter } from \\"../inputs/NestedDecimalNullableFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class DecimalNullableFilter {
  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  equals?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => [DecimalJSScalar], {
    nullable: true
  })
  in?: Prisma.Decimal[] | undefined;

  @TypeGraphQL.Field(_type => [DecimalJSScalar], {
    nullable: true
  })
  notIn?: Prisma.Decimal[] | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  lt?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  lte?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  gt?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  gte?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => NestedDecimalNullableFilter, {
    nullable: true
  })
  not?: NestedDecimalNullableFilter | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: Prisma.Decimal | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [DecimalJSScalar], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: Prisma.Decimal[] | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [DecimalJSScalar], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: Prisma.Decimal[] | undefined) {
  this.notIn = notIn;
}

@TypeGraphQL.Field(_type => DecimalJSScalar, {
  nullable: true
})
get lt() {
  return this.lt;
}

set lt(lt: Prisma.Decimal | undefined) {
  this.lt = lt;
}

@TypeGraphQL.Field(_type => DecimalJSScalar, {
  nullable: true
})
get lte() {
  return this.lte;
}

set lte(lte: Prisma.Decimal | undefined) {
  this.lte = lte;
}

@TypeGraphQL.Field(_type => DecimalJSScalar, {
  nullable: true
})
get gt() {
  return this.gt;
}

set gt(gt: Prisma.Decimal | undefined) {
  this.gt = gt;
}

@TypeGraphQL.Field(_type => DecimalJSScalar, {
  nullable: true
})
get gte() {
  return this.gte;
}

set gte(gte: Prisma.Decimal | undefined) {
  this.gte = gte;
}

@TypeGraphQL.Field(_type => NestedDecimalNullableFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedDecimalNullableFilter | undefined) {
  this.not = not;
}
}
"
`;

<<<<<<< HEAD
exports[`inputs should properly generate input type scalar filters classes for model with native types: NestedBytesNullableFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NestedBytesNullableFilter {
  @TypeGraphQL.Field(_type => GraphQLScalars.ByteResolver, {
    nullable: true
  })
  equals?: Buffer | undefined;

  @TypeGraphQL.Field(_type => NestedBytesNullableFilter, {
    nullable: true
  })
  not?: NestedBytesNullableFilter | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.ByteResolver, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: Buffer | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => NestedBytesNullableFilter, {
    nullable: true
  })
  get not() {
    return this.not;
  }

  set not(not: NestedBytesNullableFilter | undefined) {
    this.not = not;
  }
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: NestedDecimalNullableFilter 1`] = `
=======
exports[`inputs should properly generate input type scalar filters classes for model with native types: DecimalNullableWithAggregatesFilter 1`] = `
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedDecimalNullableFilter } from \\"../inputs/NestedDecimalNullableFilter\\";
import { NestedDecimalNullableWithAggregatesFilter } from \\"../inputs/NestedDecimalNullableWithAggregatesFilter\\";
import { NestedIntNullableFilter } from \\"../inputs/NestedIntNullableFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class DecimalNullableWithAggregatesFilter {
  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  equals?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => [DecimalJSScalar], {
    nullable: true
  })
  in?: Prisma.Decimal[] | undefined;

  @TypeGraphQL.Field(_type => [DecimalJSScalar], {
    nullable: true
  })
  notIn?: Prisma.Decimal[] | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  lt?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  lte?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  gt?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  gte?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => NestedDecimalNullableWithAggregatesFilter, {
    nullable: true
  })
<<<<<<< HEAD
  not?: NestedDecimalNullableFilter | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: Prisma.Decimal | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [DecimalJSScalar], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: Prisma.Decimal[] | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [DecimalJSScalar], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: Prisma.Decimal[] | undefined) {
  this.notIn = notIn;
}

@TypeGraphQL.Field(_type => DecimalJSScalar, {
  nullable: true
})
get lt() {
  return this.lt;
}

set lt(lt: Prisma.Decimal | undefined) {
  this.lt = lt;
}

@TypeGraphQL.Field(_type => DecimalJSScalar, {
  nullable: true
})
get lte() {
  return this.lte;
}

set lte(lte: Prisma.Decimal | undefined) {
  this.lte = lte;
}

@TypeGraphQL.Field(_type => DecimalJSScalar, {
  nullable: true
})
get gt() {
  return this.gt;
}

set gt(gt: Prisma.Decimal | undefined) {
  this.gt = gt;
}

@TypeGraphQL.Field(_type => DecimalJSScalar, {
  nullable: true
})
get gte() {
  return this.gte;
}

set gte(gte: Prisma.Decimal | undefined) {
  this.gte = gte;
}

@TypeGraphQL.Field(_type => NestedDecimalNullableFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedDecimalNullableFilter | undefined) {
  this.not = not;
}
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: NullableBigIntFieldUpdateOperationsInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
=======
  not?: NestedDecimalNullableWithAggregatesFilter | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e

  @TypeGraphQL.Field(_type => NestedIntNullableFilter, {
    nullable: true
  })
  _count?: NestedIntNullableFilter | undefined;

  @TypeGraphQL.Field(_type => NestedDecimalNullableFilter, {
    nullable: true
  })
  _avg?: NestedDecimalNullableFilter | undefined;

  @TypeGraphQL.Field(_type => NestedDecimalNullableFilter, {
    nullable: true
  })
  _sum?: NestedDecimalNullableFilter | undefined;

  @TypeGraphQL.Field(_type => NestedDecimalNullableFilter, {
    nullable: true
  })
  _min?: NestedDecimalNullableFilter | undefined;

  @TypeGraphQL.Field(_type => NestedDecimalNullableFilter, {
    nullable: true
  })
<<<<<<< HEAD
  divide?: bigint | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  get set() {
    return this.set;
  }

  set set(set: bigint | undefined) {
    this.set = set;
  }

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  get increment() {
    return this.increment;
  }

  set increment(increment: bigint | undefined) {
    this.increment = increment;
  }

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  get decrement() {
    return this.decrement;
  }

  set decrement(decrement: bigint | undefined) {
    this.decrement = decrement;
  }

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  get multiply() {
    return this.multiply;
  }

  set multiply(multiply: bigint | undefined) {
    this.multiply = multiply;
  }

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  get divide() {
    return this.divide;
  }

  set divide(divide: bigint | undefined) {
    this.divide = divide;
  }
=======
  _max?: NestedDecimalNullableFilter | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: NestedBytesNullableFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NestedBytesNullableFilter {
  @TypeGraphQL.Field(_type => GraphQLScalars.ByteResolver, {
    nullable: true
  })
<<<<<<< HEAD
  set?: Buffer | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.ByteResolver, {
    nullable: true
  })
  get set() {
    return this.set;
  }

  set set(set: Buffer | undefined) {
    this.set = set;
  }
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: NullableDecimalFieldUpdateOperationsInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NullableDecimalFieldUpdateOperationsInput {
  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  set?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  increment?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  decrement?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  multiply?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  divide?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  get set() {
    return this.set;
  }

  set set(set: Prisma.Decimal | undefined) {
    this.set = set;
  }

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  get increment() {
    return this.increment;
  }

  set increment(increment: Prisma.Decimal | undefined) {
    this.increment = increment;
  }

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  get decrement() {
    return this.decrement;
  }

  set decrement(decrement: Prisma.Decimal | undefined) {
    this.decrement = decrement;
  }

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  get multiply() {
    return this.multiply;
  }

  set multiply(multiply: Prisma.Decimal | undefined) {
    this.multiply = multiply;
  }
=======
  equals?: Buffer | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e

  @TypeGraphQL.Field(_type => NestedBytesNullableFilter, {
    nullable: true
  })
<<<<<<< HEAD
  get divide() {
    return this.divide;
  }

  set divide(divide: Prisma.Decimal | undefined) {
    this.divide = divide;
  }
=======
  not?: NestedBytesNullableFilter | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: NestedBytesNullableWithAggregatesFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedBytesNullableFilter } from \\"../inputs/NestedBytesNullableFilter\\";
import { NestedIntNullableFilter } from \\"../inputs/NestedIntNullableFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NestedBytesNullableWithAggregatesFilter {
  @TypeGraphQL.Field(_type => GraphQLScalars.ByteResolver, {
    nullable: true
  })
<<<<<<< HEAD
  idField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  uniqueStringField!: string;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: false
  })
  floatField!: number;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: number | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: string) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: false
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: number) {
    this.floatField = floatField;
  }
}
"
`;

exports[`inputs when \`createMany\` preview feature is enabled should properly generate input type classes for inserting many entities: SecondModelCreateManyFirstModelFieldInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
=======
  equals?: Buffer | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e

  @TypeGraphQL.Field(_type => NestedBytesNullableWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedBytesNullableWithAggregatesFilter | undefined;

  @TypeGraphQL.Field(_type => NestedIntNullableFilter, {
    nullable: true
  })
<<<<<<< HEAD
  floatField!: number;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: number | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: string) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: false
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: number) {
    this.floatField = floatField;
  }
}
"
`;

exports[`inputs when \`createMany\` preview feature is enabled should properly generate input type classes for inserting many entities: SecondModelCreateManyFirstModelFieldInputEnvelope 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SecondModelCreateManyFirstModelFieldInput } from \\"../inputs/SecondModelCreateManyFirstModelFieldInput\\";
=======
  _count?: NestedIntNullableFilter | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e

  @TypeGraphQL.Field(_type => NestedBytesNullableFilter, {
    nullable: true
  })
  _min?: NestedBytesNullableFilter | undefined;

  @TypeGraphQL.Field(_type => NestedBytesNullableFilter, {
    nullable: true
  })
<<<<<<< HEAD
  skipDuplicates?: boolean | undefined;

  @TypeGraphQL.Field(_type => [SecondModelCreateManyFirstModelFieldInput], {
    nullable: false
  })
  get data() {
    return this.data;
  }

  set data(data: SecondModelCreateManyFirstModelFieldInput[]) {
    this.data = data;
  }

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  get skipDuplicates() {
    return this.skipDuplicates;
  }

  set skipDuplicates(skipDuplicates: boolean | undefined) {
    this.skipDuplicates = skipDuplicates;
  }
=======
  _max?: NestedBytesNullableFilter | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: NestedDecimalNullableFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NestedDecimalNullableFilter {
  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  equals?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => [DecimalJSScalar], {
    nullable: true
  })
<<<<<<< HEAD
  firstModelFieldId!: number;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: number | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: string) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: false
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: number) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: false
  })
  get firstModelFieldId() {
    return this.firstModelFieldId;
  }

  set firstModelFieldId(firstModelFieldId: number) {
    this.firstModelFieldId = firstModelFieldId;
  }
}
"
`;

exports[`inputs when \`createMany\` preview feature is enabled should properly generate input type classes for inserting many entities: index 1`] = `
"export { FirstModelCreateInput } from \\"./FirstModelCreateInput\\";
export { FirstModelCreateManyInput } from \\"./FirstModelCreateManyInput\\";
export { FirstModelCreateNestedOneWithoutSecondModelsFieldInput } from \\"./FirstModelCreateNestedOneWithoutSecondModelsFieldInput\\";
export { FirstModelCreateOrConnectWithoutSecondModelsFieldInput } from \\"./FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export { FirstModelCreateWithoutSecondModelsFieldInput } from \\"./FirstModelCreateWithoutSecondModelsFieldInput\\";
export { FirstModelOrderByInput } from \\"./FirstModelOrderByInput\\";
export { FirstModelRelationFilter } from \\"./FirstModelRelationFilter\\";
export { FirstModelUpdateInput } from \\"./FirstModelUpdateInput\\";
export { FirstModelUpdateManyMutationInput } from \\"./FirstModelUpdateManyMutationInput\\";
export { FirstModelUpdateOneRequiredWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateOneRequiredWithoutSecondModelsFieldInput\\";
export { FirstModelUpdateWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateWithoutSecondModelsFieldInput\\";
export { FirstModelUpsertWithoutSecondModelsFieldInput } from \\"./FirstModelUpsertWithoutSecondModelsFieldInput\\";
export { FirstModelWhereInput } from \\"./FirstModelWhereInput\\";
export { FirstModelWhereUniqueInput } from \\"./FirstModelWhereUniqueInput\\";
export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { SecondModelCreateInput } from \\"./SecondModelCreateInput\\";
export { SecondModelCreateManyFirstModelFieldInput } from \\"./SecondModelCreateManyFirstModelFieldInput\\";
export { SecondModelCreateManyFirstModelFieldInputEnvelope } from \\"./SecondModelCreateManyFirstModelFieldInputEnvelope\\";
export { SecondModelCreateManyInput } from \\"./SecondModelCreateManyInput\\";
export { SecondModelCreateNestedManyWithoutFirstModelFieldInput } from \\"./SecondModelCreateNestedManyWithoutFirstModelFieldInput\\";
export { SecondModelCreateOrConnectWithoutFirstModelFieldInput } from \\"./SecondModelCreateOrConnectWithoutFirstModelFieldInput\\";
export { SecondModelCreateWithoutFirstModelFieldInput } from \\"./SecondModelCreateWithoutFirstModelFieldInput\\";
export { SecondModelListRelationFilter } from \\"./SecondModelListRelationFilter\\";
export { SecondModelOrderByInput } from \\"./SecondModelOrderByInput\\";
export { SecondModelScalarWhereInput } from \\"./SecondModelScalarWhereInput\\";
export { SecondModelUpdateInput } from \\"./SecondModelUpdateInput\\";
export { SecondModelUpdateManyMutationInput } from \\"./SecondModelUpdateManyMutationInput\\";
export { SecondModelUpdateManyWithWhereWithoutFirstModelFieldInput } from \\"./SecondModelUpdateManyWithWhereWithoutFirstModelFieldInput\\";
export { SecondModelUpdateManyWithoutFirstModelFieldInput } from \\"./SecondModelUpdateManyWithoutFirstModelFieldInput\\";
export { SecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput } from \\"./SecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput\\";
export { SecondModelUpdateWithoutFirstModelFieldInput } from \\"./SecondModelUpdateWithoutFirstModelFieldInput\\";
export { SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput } from \\"./SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput\\";
export { SecondModelWhereInput } from \\"./SecondModelWhereInput\\";
export { SecondModelWhereUniqueInput } from \\"./SecondModelWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
"
`;
=======
  in?: Prisma.Decimal[] | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e

  @TypeGraphQL.Field(_type => [DecimalJSScalar], {
    nullable: true
  })
  notIn?: Prisma.Decimal[] | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  lt?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  lte?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  gt?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  gte?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => NestedDecimalNullableFilter, {
    nullable: true
  })
<<<<<<< HEAD
  secondModelsField?: SecondModelOrderByAggregateInput | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: \\"asc\\" | \\"desc\\" | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: \\"asc\\" | \\"desc\\" | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: \\"asc\\" | \\"desc\\" | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => SecondModelOrderByAggregateInput, {
    nullable: true
  })
  get secondModelsField() {
    return this.secondModelsField;
  }

  set secondModelsField(secondModelsField: SecondModelOrderByAggregateInput | undefined) {
    this.secondModelsField = secondModelsField;
  }
=======
  not?: NestedDecimalNullableFilter | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: NestedDecimalNullableWithAggregatesFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedDecimalNullableFilter } from \\"../inputs/NestedDecimalNullableFilter\\";
import { NestedIntNullableFilter } from \\"../inputs/NestedIntNullableFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NestedDecimalNullableWithAggregatesFilter {
  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
<<<<<<< HEAD
  count!: \\"asc\\" | \\"desc\\";

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: false
  })
  get count() {
    return this.count;
  }

  set count(count: \\"asc\\" | \\"desc\\") {
    this.count = count;
  }
}
"
`;
=======
  equals?: Prisma.Decimal | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e

  @TypeGraphQL.Field(_type => [DecimalJSScalar], {
    nullable: true
  })
  in?: Prisma.Decimal[] | undefined;

  @TypeGraphQL.Field(_type => [DecimalJSScalar], {
    nullable: true
  })
  notIn?: Prisma.Decimal[] | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  lt?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  lte?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  gt?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  gte?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => NestedDecimalNullableWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedDecimalNullableWithAggregatesFilter | undefined;

  @TypeGraphQL.Field(_type => NestedIntNullableFilter, {
    nullable: true
  })
  _count?: NestedIntNullableFilter | undefined;

  @TypeGraphQL.Field(_type => NestedDecimalNullableFilter, {
    nullable: true
  })
  _avg?: NestedDecimalNullableFilter | undefined;

  @TypeGraphQL.Field(_type => NestedDecimalNullableFilter, {
    nullable: true
  })
  _sum?: NestedDecimalNullableFilter | undefined;

  @TypeGraphQL.Field(_type => NestedDecimalNullableFilter, {
    nullable: true
  })
  _min?: NestedDecimalNullableFilter | undefined;

  @TypeGraphQL.Field(_type => NestedDecimalNullableFilter, {
    nullable: true
  })
  _max?: NestedDecimalNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: NullableBigIntFieldUpdateOperationsInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NullableBigIntFieldUpdateOperationsInput {
  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  set?: bigint | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  increment?: bigint | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  decrement?: bigint | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  multiply?: bigint | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
<<<<<<< HEAD
  secondModelsField?: SecondModelOrderByAggregateInput | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: \\"asc\\" | \\"desc\\" | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: \\"asc\\" | \\"desc\\" | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: \\"asc\\" | \\"desc\\" | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => SecondModelOrderByAggregateInput, {
    nullable: true
  })
  get secondModelsField() {
    return this.secondModelsField;
  }

  set secondModelsField(secondModelsField: SecondModelOrderByAggregateInput | undefined) {
    this.secondModelsField = secondModelsField;
  }
=======
  divide?: bigint | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: NullableBytesFieldUpdateOperationsInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NullableBytesFieldUpdateOperationsInput {
  @TypeGraphQL.Field(_type => GraphQLScalars.ByteResolver, {
    nullable: true
  })
<<<<<<< HEAD
  count!: \\"asc\\" | \\"desc\\";

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: false
  })
  get count() {
    return this.count;
  }

  set count(count: \\"asc\\" | \\"desc\\") {
    this.count = count;
  }
=======
  set?: Buffer | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: NullableDecimalFieldUpdateOperationsInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class NullableDecimalFieldUpdateOperationsInput {
  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  set?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  increment?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  decrement?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
  multiply?: Prisma.Decimal | undefined;

  @TypeGraphQL.Field(_type => DecimalJSScalar, {
    nullable: true
  })
<<<<<<< HEAD
  firstModelField?: FirstModelOrderByWithRelationInput | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: \\"asc\\" | \\"desc\\" | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: \\"asc\\" | \\"desc\\" | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: \\"asc\\" | \\"desc\\" | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get firstModelFieldId() {
    return this.firstModelFieldId;
  }

  set firstModelFieldId(firstModelFieldId: \\"asc\\" | \\"desc\\" | undefined) {
    this.firstModelFieldId = firstModelFieldId;
  }

  @TypeGraphQL.Field(_type => FirstModelOrderByWithRelationInput, {
    nullable: true
  })
  get firstModelField() {
    return this.firstModelField;
  }

  set firstModelField(firstModelField: FirstModelOrderByWithRelationInput | undefined) {
    this.firstModelField = firstModelField;
  }
=======
  divide?: Prisma.Decimal | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: index 1`] = `
"export { BigIntNullableFilter } from \\"./BigIntNullableFilter\\";
export { BigIntNullableWithAggregatesFilter } from \\"./BigIntNullableWithAggregatesFilter\\";
export { BytesNullableFilter } from \\"./BytesNullableFilter\\";
export { BytesNullableWithAggregatesFilter } from \\"./BytesNullableWithAggregatesFilter\\";
export { DecimalNullableFilter } from \\"./DecimalNullableFilter\\";
export { DecimalNullableWithAggregatesFilter } from \\"./DecimalNullableWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { NativeTypeModelCreateInput } from \\"./NativeTypeModelCreateInput\\";
export { NativeTypeModelCreateManyInput } from \\"./NativeTypeModelCreateManyInput\\";
export { NativeTypeModelOrderByInput } from \\"./NativeTypeModelOrderByInput\\";
export { NativeTypeModelScalarWhereWithAggregatesInput } from \\"./NativeTypeModelScalarWhereWithAggregatesInput\\";
export { NativeTypeModelUpdateInput } from \\"./NativeTypeModelUpdateInput\\";
export { NativeTypeModelUpdateManyMutationInput } from \\"./NativeTypeModelUpdateManyMutationInput\\";
export { NativeTypeModelWhereInput } from \\"./NativeTypeModelWhereInput\\";
export { NativeTypeModelWhereUniqueInput } from \\"./NativeTypeModelWhereUniqueInput\\";
export { NestedBigIntNullableFilter } from \\"./NestedBigIntNullableFilter\\";
export { NestedBigIntNullableWithAggregatesFilter } from \\"./NestedBigIntNullableWithAggregatesFilter\\";
export { NestedBytesNullableFilter } from \\"./NestedBytesNullableFilter\\";
export { NestedBytesNullableWithAggregatesFilter } from \\"./NestedBytesNullableWithAggregatesFilter\\";
export { NestedDecimalNullableFilter } from \\"./NestedDecimalNullableFilter\\";
export { NestedDecimalNullableWithAggregatesFilter } from \\"./NestedDecimalNullableWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatNullableFilter } from \\"./NestedFloatNullableFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntNullableFilter } from \\"./NestedIntNullableFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NullableBigIntFieldUpdateOperationsInput } from \\"./NullableBigIntFieldUpdateOperationsInput\\";
export { NullableBytesFieldUpdateOperationsInput } from \\"./NullableBytesFieldUpdateOperationsInput\\";
export { NullableDecimalFieldUpdateOperationsInput } from \\"./NullableDecimalFieldUpdateOperationsInput\\";
"
`;

exports[`inputs when \`orderByAggregateGroup\` preview feature is enabled should properly generate input type classes for sorting by many-to-many relation fields: SampleAvgOrderByAggregateInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleAvgOrderByAggregateInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
<<<<<<< HEAD
  get idField() {
    return this.idField;
  }

  set idField(idField: \\"asc\\" | \\"desc\\" | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get mappedFieldName() {
    return this.modelFieldName;
  }

  set mappedFieldName(modelFieldName: \\"asc\\" | \\"desc\\" | undefined) {
    this.modelFieldName = modelFieldName;
  }
=======
  intField?: \\"asc\\" | \\"desc\\" | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when \`orderByAggregateGroup\` preview feature is enabled should properly generate input type classes for sorting by many-to-many relation fields: SampleCountOrderByAggregateInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleCountOrderByAggregateInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  stringField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  intField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  booleanField?: \\"asc\\" | \\"desc\\" | undefined;

<<<<<<< HEAD
  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: SampleWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: SampleWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: SampleWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: IntFilter | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
=======
  @TypeGraphQL.Field(_type => SortOrder, {
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
    nullable: true
  })
  dateField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  jsonField?: \\"asc\\" | \\"desc\\" | undefined;
}
"
`;

exports[`inputs when \`orderByAggregateGroup\` preview feature is enabled should properly generate input type classes for sorting by many-to-many relation fields: SampleMaxOrderByAggregateInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleMaxOrderByAggregateInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
<<<<<<< HEAD
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: \\"asc\\" | \\"desc\\" | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: \\"asc\\" | \\"desc\\" | undefined) {
    this.uniqueStringField = uniqueStringField;
  }
=======
  stringField?: \\"asc\\" | \\"desc\\" | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
<<<<<<< HEAD
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: \\"asc\\" | \\"desc\\" | undefined) {
    this.floatField = floatField;
  }
=======
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  intField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  booleanField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  dateField?: \\"asc\\" | \\"desc\\" | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when \`orderByAggregateGroup\` preview feature is enabled should properly generate input type classes for sorting by many-to-many relation fields: SampleMinOrderByAggregateInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleMinOrderByAggregateInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  stringField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  intField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  booleanField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
<<<<<<< HEAD
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => [RenamedFirstModelScalarWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: RenamedFirstModelScalarWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [RenamedFirstModelScalarWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: RenamedFirstModelScalarWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [RenamedFirstModelScalarWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: RenamedFirstModelScalarWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: IntFilter | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: StringFilter | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFilter | undefined) {
    this.floatField = floatField;
  }
=======
  dateField?: \\"asc\\" | \\"desc\\" | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when \`orderByAggregateGroup\` preview feature is enabled should properly generate input type classes for sorting by many-to-many relation fields: SampleOrderByWithAggregationInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SampleAvgOrderByAggregateInput } from \\"../inputs/SampleAvgOrderByAggregateInput\\";
import { SampleCountOrderByAggregateInput } from \\"../inputs/SampleCountOrderByAggregateInput\\";
import { SampleMaxOrderByAggregateInput } from \\"../inputs/SampleMaxOrderByAggregateInput\\";
import { SampleMinOrderByAggregateInput } from \\"../inputs/SampleMinOrderByAggregateInput\\";
import { SampleSumOrderByAggregateInput } from \\"../inputs/SampleSumOrderByAggregateInput\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleOrderByWithAggregationInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  stringField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  intField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  booleanField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  dateField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
<<<<<<< HEAD
  secondModelsField?: RenamedSecondModelListRelationFilter | undefined;

  @TypeGraphQL.Field(_type => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: RenamedFirstModelWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: RenamedFirstModelWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: RenamedFirstModelWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: IntFilter | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: StringFilter | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFilter | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => RenamedSecondModelListRelationFilter, {
    nullable: true
  })
  get secondModelsField() {
    return this.secondModelsField;
  }

  set secondModelsField(secondModelsField: RenamedSecondModelListRelationFilter | undefined) {
    this.secondModelsField = secondModelsField;
  }
=======
  jsonField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SampleCountOrderByAggregateInput, {
    nullable: true
  })
  _count?: SampleCountOrderByAggregateInput | undefined;

  @TypeGraphQL.Field(_type => SampleAvgOrderByAggregateInput, {
    nullable: true
  })
  _avg?: SampleAvgOrderByAggregateInput | undefined;

  @TypeGraphQL.Field(_type => SampleMaxOrderByAggregateInput, {
    nullable: true
  })
  _max?: SampleMaxOrderByAggregateInput | undefined;

  @TypeGraphQL.Field(_type => SampleMinOrderByAggregateInput, {
    nullable: true
  })
  _min?: SampleMinOrderByAggregateInput | undefined;

  @TypeGraphQL.Field(_type => SampleSumOrderByAggregateInput, {
    nullable: true
  })
  _sum?: SampleSumOrderByAggregateInput | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when \`orderByAggregateGroup\` preview feature is enabled should properly generate input type classes for sorting by many-to-many relation fields: index 1`] = `
"export { BoolFieldUpdateOperationsInput } from \\"./BoolFieldUpdateOperationsInput\\";
export { BoolFilter } from \\"./BoolFilter\\";
export { BoolWithAggregatesFilter } from \\"./BoolWithAggregatesFilter\\";
export { DateTimeFieldUpdateOperationsInput } from \\"./DateTimeFieldUpdateOperationsInput\\";
export { DateTimeFilter } from \\"./DateTimeFilter\\";
export { DateTimeWithAggregatesFilter } from \\"./DateTimeWithAggregatesFilter\\";
export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { FloatWithAggregatesFilter } from \\"./FloatWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { JsonFilter } from \\"./JsonFilter\\";
export { JsonWithAggregatesFilter } from \\"./JsonWithAggregatesFilter\\";
export { NestedBoolFilter } from \\"./NestedBoolFilter\\";
export { NestedBoolWithAggregatesFilter } from \\"./NestedBoolWithAggregatesFilter\\";
export { NestedDateTimeFilter } from \\"./NestedDateTimeFilter\\";
export { NestedDateTimeWithAggregatesFilter } from \\"./NestedDateTimeWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatWithAggregatesFilter } from \\"./NestedFloatWithAggregatesFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedJsonFilter } from \\"./NestedJsonFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { SampleAvgOrderByAggregateInput } from \\"./SampleAvgOrderByAggregateInput\\";
export { SampleCountOrderByAggregateInput } from \\"./SampleCountOrderByAggregateInput\\";
export { SampleCreateInput } from \\"./SampleCreateInput\\";
export { SampleCreateManyInput } from \\"./SampleCreateManyInput\\";
export { SampleMaxOrderByAggregateInput } from \\"./SampleMaxOrderByAggregateInput\\";
export { SampleMinOrderByAggregateInput } from \\"./SampleMinOrderByAggregateInput\\";
export { SampleOrderByInput } from \\"./SampleOrderByInput\\";
export { SampleOrderByWithAggregationInput } from \\"./SampleOrderByWithAggregationInput\\";
export { SampleScalarWhereWithAggregatesInput } from \\"./SampleScalarWhereWithAggregatesInput\\";
export { SampleSumOrderByAggregateInput } from \\"./SampleSumOrderByAggregateInput\\";
export { SampleUpdateInput } from \\"./SampleUpdateInput\\";
export { SampleUpdateManyMutationInput } from \\"./SampleUpdateManyMutationInput\\";
export { SampleWhereInput } from \\"./SampleWhereInput\\";
export { SampleWhereUniqueInput } from \\"./SampleWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs when \`orderByRelation\` preview feature is enabled should properly generate input type classes for sorting by many-to-many relation fields: FirstModelOrderByWithRelationInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SecondModelOrderByRelationAggregateInput } from \\"../inputs/SecondModelOrderByRelationAggregateInput\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelOrderByWithRelationInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
<<<<<<< HEAD
  uniqueStringField?: string | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: number | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: string | undefined) {
    this.uniqueStringField = uniqueStringField;
  }
=======
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SecondModelOrderByRelationAggregateInput, {
    nullable: true
  })
  secondModelsField?: SecondModelOrderByRelationAggregateInput | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when \`orderByRelation\` preview feature is enabled should properly generate input type classes for sorting by many-to-many relation fields: SecondModelOrderByRelationAggregateInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SecondModelOrderByRelationAggregateInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  _count?: \\"asc\\" | \\"desc\\" | undefined;
}
"
`;

exports[`inputs when \`orderByRelation\` preview feature is enabled should properly generate input type classes for sorting by many-to-many relation fields: index 1`] = `
"export { FirstModelCreateInput } from \\"./FirstModelCreateInput\\";
export { FirstModelCreateManyInput } from \\"./FirstModelCreateManyInput\\";
export { FirstModelCreateNestedManyWithoutSecondModelsFieldInput } from \\"./FirstModelCreateNestedManyWithoutSecondModelsFieldInput\\";
export { FirstModelCreateOrConnectWithoutSecondModelsFieldInput } from \\"./FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export { FirstModelCreateWithoutSecondModelsFieldInput } from \\"./FirstModelCreateWithoutSecondModelsFieldInput\\";
export { FirstModelListRelationFilter } from \\"./FirstModelListRelationFilter\\";
export { FirstModelOrderByInput } from \\"./FirstModelOrderByInput\\";
export { FirstModelOrderByRelationAggregateInput } from \\"./FirstModelOrderByRelationAggregateInput\\";
export { FirstModelOrderByWithRelationInput } from \\"./FirstModelOrderByWithRelationInput\\";
export { FirstModelScalarWhereInput } from \\"./FirstModelScalarWhereInput\\";
export { FirstModelScalarWhereWithAggregatesInput } from \\"./FirstModelScalarWhereWithAggregatesInput\\";
export { FirstModelUpdateInput } from \\"./FirstModelUpdateInput\\";
export { FirstModelUpdateManyMutationInput } from \\"./FirstModelUpdateManyMutationInput\\";
export { FirstModelUpdateManyWithWhereWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateManyWithWhereWithoutSecondModelsFieldInput\\";
export { FirstModelUpdateManyWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateManyWithoutSecondModelsFieldInput\\";
export { FirstModelUpdateWithWhereUniqueWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateWithWhereUniqueWithoutSecondModelsFieldInput\\";
export { FirstModelUpdateWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateWithoutSecondModelsFieldInput\\";
export { FirstModelUpsertWithWhereUniqueWithoutSecondModelsFieldInput } from \\"./FirstModelUpsertWithWhereUniqueWithoutSecondModelsFieldInput\\";
export { FirstModelWhereInput } from \\"./FirstModelWhereInput\\";
export { FirstModelWhereUniqueInput } from \\"./FirstModelWhereUniqueInput\\";
export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { FloatWithAggregatesFilter } from \\"./FloatWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatWithAggregatesFilter } from \\"./NestedFloatWithAggregatesFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { SecondModelCreateInput } from \\"./SecondModelCreateInput\\";
export { SecondModelCreateManyInput } from \\"./SecondModelCreateManyInput\\";
export { SecondModelCreateNestedManyWithoutFirstModelsFieldInput } from \\"./SecondModelCreateNestedManyWithoutFirstModelsFieldInput\\";
export { SecondModelCreateOrConnectWithoutFirstModelsFieldInput } from \\"./SecondModelCreateOrConnectWithoutFirstModelsFieldInput\\";
export { SecondModelCreateWithoutFirstModelsFieldInput } from \\"./SecondModelCreateWithoutFirstModelsFieldInput\\";
export { SecondModelListRelationFilter } from \\"./SecondModelListRelationFilter\\";
export { SecondModelOrderByInput } from \\"./SecondModelOrderByInput\\";
export { SecondModelOrderByRelationAggregateInput } from \\"./SecondModelOrderByRelationAggregateInput\\";
export { SecondModelOrderByWithRelationInput } from \\"./SecondModelOrderByWithRelationInput\\";
export { SecondModelScalarWhereInput } from \\"./SecondModelScalarWhereInput\\";
export { SecondModelScalarWhereWithAggregatesInput } from \\"./SecondModelScalarWhereWithAggregatesInput\\";
export { SecondModelUpdateInput } from \\"./SecondModelUpdateInput\\";
export { SecondModelUpdateManyMutationInput } from \\"./SecondModelUpdateManyMutationInput\\";
export { SecondModelUpdateManyWithWhereWithoutFirstModelsFieldInput } from \\"./SecondModelUpdateManyWithWhereWithoutFirstModelsFieldInput\\";
export { SecondModelUpdateManyWithoutFirstModelsFieldInput } from \\"./SecondModelUpdateManyWithoutFirstModelsFieldInput\\";
export { SecondModelUpdateWithWhereUniqueWithoutFirstModelsFieldInput } from \\"./SecondModelUpdateWithWhereUniqueWithoutFirstModelsFieldInput\\";
export { SecondModelUpdateWithoutFirstModelsFieldInput } from \\"./SecondModelUpdateWithoutFirstModelsFieldInput\\";
export { SecondModelUpsertWithWhereUniqueWithoutFirstModelsFieldInput } from \\"./SecondModelUpsertWithWhereUniqueWithoutFirstModelsFieldInput\\";
export { SecondModelWhereInput } from \\"./SecondModelWhereInput\\";
export { SecondModelWhereUniqueInput } from \\"./SecondModelWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs when \`orderByRelation\` preview feature is enabled should properly generate input type classes for sorting by one-to-many relation fields: FirstModelOrderByWithRelationInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SecondModelOrderByRelationAggregateInput } from \\"../inputs/SecondModelOrderByRelationAggregateInput\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelOrderByWithRelationInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

<<<<<<< HEAD
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: \\"asc\\" | \\"desc\\" | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: \\"asc\\" | \\"desc\\" | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: \\"asc\\" | \\"desc\\" | undefined) {
    this.floatField = floatField;
  }
=======
  @TypeGraphQL.Field(_type => SecondModelOrderByRelationAggregateInput, {
    nullable: true
  })
  secondModelsField?: SecondModelOrderByRelationAggregateInput | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when \`orderByRelation\` preview feature is enabled should properly generate input type classes for sorting by one-to-many relation fields: SecondModelOrderByRelationAggregateInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SecondModelOrderByRelationAggregateInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
<<<<<<< HEAD
  isNot?: RenamedFirstModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => RenamedFirstModelWhereInput, {
    nullable: true
  })
  get is() {
    return this.is;
  }

  set is(is: RenamedFirstModelWhereInput | undefined) {
    this.is = is;
  }

  @TypeGraphQL.Field(_type => RenamedFirstModelWhereInput, {
    nullable: true
  })
  get isNot() {
    return this.isNot;
  }

  set isNot(isNot: RenamedFirstModelWhereInput | undefined) {
    this.isNot = isNot;
  }
=======
  _count?: \\"asc\\" | \\"desc\\" | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when \`orderByRelation\` preview feature is enabled should properly generate input type classes for sorting by one-to-many relation fields: SecondModelOrderByWithRelationInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelOrderByWithRelationInput } from \\"../inputs/FirstModelOrderByWithRelationInput\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SecondModelOrderByWithRelationInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  firstModelFieldId?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => FirstModelOrderByWithRelationInput, {
    nullable: true
  })
<<<<<<< HEAD
  secondModelsField?: RenamedSecondModelListRelationFilter | undefined;

  @TypeGraphQL.Field(_type => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: RenamedFirstModelWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: RenamedFirstModelWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: RenamedFirstModelWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: IntFilter | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: StringFilter | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFilter | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => RenamedSecondModelListRelationFilter, {
    nullable: true
  })
  get secondModelsField() {
    return this.secondModelsField;
  }

  set secondModelsField(secondModelsField: RenamedSecondModelListRelationFilter | undefined) {
    this.secondModelsField = secondModelsField;
  }
=======
  firstModelField?: FirstModelOrderByWithRelationInput | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when \`orderByRelation\` preview feature is enabled should properly generate input type classes for sorting by one-to-many relation fields: index 1`] = `
"export { FirstModelCreateInput } from \\"./FirstModelCreateInput\\";
export { FirstModelCreateManyInput } from \\"./FirstModelCreateManyInput\\";
export { FirstModelCreateNestedOneWithoutSecondModelsFieldInput } from \\"./FirstModelCreateNestedOneWithoutSecondModelsFieldInput\\";
export { FirstModelCreateOrConnectWithoutSecondModelsFieldInput } from \\"./FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export { FirstModelCreateWithoutSecondModelsFieldInput } from \\"./FirstModelCreateWithoutSecondModelsFieldInput\\";
export { FirstModelOrderByInput } from \\"./FirstModelOrderByInput\\";
export { FirstModelOrderByWithRelationInput } from \\"./FirstModelOrderByWithRelationInput\\";
export { FirstModelRelationFilter } from \\"./FirstModelRelationFilter\\";
export { FirstModelScalarWhereWithAggregatesInput } from \\"./FirstModelScalarWhereWithAggregatesInput\\";
export { FirstModelUpdateInput } from \\"./FirstModelUpdateInput\\";
export { FirstModelUpdateManyMutationInput } from \\"./FirstModelUpdateManyMutationInput\\";
export { FirstModelUpdateOneRequiredWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateOneRequiredWithoutSecondModelsFieldInput\\";
export { FirstModelUpdateWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateWithoutSecondModelsFieldInput\\";
export { FirstModelUpsertWithoutSecondModelsFieldInput } from \\"./FirstModelUpsertWithoutSecondModelsFieldInput\\";
export { FirstModelWhereInput } from \\"./FirstModelWhereInput\\";
export { FirstModelWhereUniqueInput } from \\"./FirstModelWhereUniqueInput\\";
export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { FloatWithAggregatesFilter } from \\"./FloatWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatWithAggregatesFilter } from \\"./NestedFloatWithAggregatesFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { SecondModelCreateInput } from \\"./SecondModelCreateInput\\";
export { SecondModelCreateManyFirstModelFieldInput } from \\"./SecondModelCreateManyFirstModelFieldInput\\";
export { SecondModelCreateManyFirstModelFieldInputEnvelope } from \\"./SecondModelCreateManyFirstModelFieldInputEnvelope\\";
export { SecondModelCreateManyInput } from \\"./SecondModelCreateManyInput\\";
export { SecondModelCreateNestedManyWithoutFirstModelFieldInput } from \\"./SecondModelCreateNestedManyWithoutFirstModelFieldInput\\";
export { SecondModelCreateOrConnectWithoutFirstModelFieldInput } from \\"./SecondModelCreateOrConnectWithoutFirstModelFieldInput\\";
export { SecondModelCreateWithoutFirstModelFieldInput } from \\"./SecondModelCreateWithoutFirstModelFieldInput\\";
export { SecondModelListRelationFilter } from \\"./SecondModelListRelationFilter\\";
export { SecondModelOrderByInput } from \\"./SecondModelOrderByInput\\";
export { SecondModelOrderByRelationAggregateInput } from \\"./SecondModelOrderByRelationAggregateInput\\";
export { SecondModelOrderByWithRelationInput } from \\"./SecondModelOrderByWithRelationInput\\";
export { SecondModelScalarWhereInput } from \\"./SecondModelScalarWhereInput\\";
export { SecondModelScalarWhereWithAggregatesInput } from \\"./SecondModelScalarWhereWithAggregatesInput\\";
export { SecondModelUpdateInput } from \\"./SecondModelUpdateInput\\";
export { SecondModelUpdateManyMutationInput } from \\"./SecondModelUpdateManyMutationInput\\";
export { SecondModelUpdateManyWithWhereWithoutFirstModelFieldInput } from \\"./SecondModelUpdateManyWithWhereWithoutFirstModelFieldInput\\";
export { SecondModelUpdateManyWithoutFirstModelFieldInput } from \\"./SecondModelUpdateManyWithoutFirstModelFieldInput\\";
export { SecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput } from \\"./SecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput\\";
export { SecondModelUpdateWithoutFirstModelFieldInput } from \\"./SecondModelUpdateWithoutFirstModelFieldInput\\";
export { SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput } from \\"./SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput\\";
export { SecondModelWhereInput } from \\"./SecondModelWhereInput\\";
export { SecondModelWhereUniqueInput } from \\"./SecondModelWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs when model field is renamed should properly generate input type classes: SampleOrderByInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleOrderByInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  modelFieldName?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
<<<<<<< HEAD
  uniqueStringField?: string | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: number | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: string | undefined) {
    this.uniqueStringField = uniqueStringField;
=======
  get mappedFieldName() {
    return this.modelFieldName;
  }

  set mappedFieldName(modelFieldName: \\"asc\\" | \\"desc\\" | undefined) {
    this.modelFieldName = modelFieldName;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
  }
}
"
`;

exports[`inputs when model field is renamed should properly generate input type classes: SampleWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleWhereInput {
  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true
  })
  AND?: SampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true
  })
  OR?: SampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true
  })
<<<<<<< HEAD
  none?: RenamedSecondModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => RenamedSecondModelWhereInput, {
    nullable: true
  })
  get every() {
    return this.every;
  }

  set every(every: RenamedSecondModelWhereInput | undefined) {
    this.every = every;
  }

  @TypeGraphQL.Field(_type => RenamedSecondModelWhereInput, {
    nullable: true
  })
  get some() {
    return this.some;
  }

  set some(some: RenamedSecondModelWhereInput | undefined) {
    this.some = some;
  }

  @TypeGraphQL.Field(_type => RenamedSecondModelWhereInput, {
    nullable: true
  })
  get none() {
    return this.none;
  }

  set none(none: RenamedSecondModelWhereInput | undefined) {
    this.none = none;
=======
  NOT?: SampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  modelFieldName?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get mappedFieldName() {
    return this.modelFieldName;
  }

  set mappedFieldName(modelFieldName: StringFilter | undefined) {
    this.modelFieldName = modelFieldName;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
  }
}
"
`;

exports[`inputs when model field is renamed should properly generate input type classes: index 1`] = `
"export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { SampleCreateInput } from \\"./SampleCreateInput\\";
export { SampleCreateManyInput } from \\"./SampleCreateManyInput\\";
export { SampleOrderByInput } from \\"./SampleOrderByInput\\";
export { SampleScalarWhereWithAggregatesInput } from \\"./SampleScalarWhereWithAggregatesInput\\";
export { SampleUpdateInput } from \\"./SampleUpdateInput\\";
export { SampleUpdateManyMutationInput } from \\"./SampleUpdateManyMutationInput\\";
export { SampleWhereInput } from \\"./SampleWhereInput\\";
export { SampleWhereUniqueInput } from \\"./SampleWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by many to many relation fields: RenamedFirstModelOrderByInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class RenamedFirstModelOrderByInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  firstModelFieldId?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: \\"asc\\" | \\"desc\\" | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: \\"asc\\" | \\"desc\\" | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
<<<<<<< HEAD
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: \\"asc\\" | \\"desc\\" | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get firstModelFieldId() {
    return this.firstModelFieldId;
  }

  set firstModelFieldId(firstModelFieldId: \\"asc\\" | \\"desc\\" | undefined) {
    this.firstModelFieldId = firstModelFieldId;
  }
=======
  floatField?: \\"asc\\" | \\"desc\\" | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by many to many relation fields: RenamedFirstModelScalarWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class RenamedFirstModelScalarWhereInput {
  @TypeGraphQL.Field(_type => [RenamedFirstModelScalarWhereInput], {
    nullable: true
  })
  AND?: RenamedFirstModelScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [RenamedFirstModelScalarWhereInput], {
    nullable: true
  })
  OR?: RenamedFirstModelScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [RenamedFirstModelScalarWhereInput], {
    nullable: true
  })
  NOT?: RenamedFirstModelScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;
<<<<<<< HEAD

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  firstModelFieldId?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => [RenamedSecondModelScalarWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: RenamedSecondModelScalarWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [RenamedSecondModelScalarWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: RenamedSecondModelScalarWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [RenamedSecondModelScalarWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: RenamedSecondModelScalarWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: IntFilter | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: StringFilter | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFilter | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get firstModelFieldId() {
    return this.firstModelFieldId;
  }

  set firstModelFieldId(firstModelFieldId: IntFilter | undefined) {
    this.firstModelFieldId = firstModelFieldId;
  }
=======
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by many to many relation fields: RenamedFirstModelWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { RenamedSecondModelListRelationFilter } from \\"../inputs/RenamedSecondModelListRelationFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class RenamedFirstModelWhereInput {
  @TypeGraphQL.Field(_type => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  AND?: RenamedFirstModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  OR?: RenamedFirstModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  NOT?: RenamedFirstModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => RenamedSecondModelListRelationFilter, {
    nullable: true
  })
<<<<<<< HEAD
  firstModelField?: RenamedFirstModelRelationFilter | undefined;

  @TypeGraphQL.Field(_type => [RenamedSecondModelWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: RenamedSecondModelWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [RenamedSecondModelWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: RenamedSecondModelWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [RenamedSecondModelWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: RenamedSecondModelWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: IntFilter | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: StringFilter | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFilter | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get firstModelFieldId() {
    return this.firstModelFieldId;
  }

  set firstModelFieldId(firstModelFieldId: IntFilter | undefined) {
    this.firstModelFieldId = firstModelFieldId;
  }

  @TypeGraphQL.Field(_type => RenamedFirstModelRelationFilter, {
    nullable: true
  })
  get firstModelField() {
    return this.firstModelField;
  }

  set firstModelField(firstModelField: RenamedFirstModelRelationFilter | undefined) {
    this.firstModelField = firstModelField;
  }
=======
  secondModelsField?: RenamedSecondModelListRelationFilter | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by many to many relation fields: RenamedFirstModelWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class RenamedFirstModelWhereUniqueInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  idField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  uniqueStringField?: string | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: number | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: string | undefined) {
    this.uniqueStringField = uniqueStringField;
  }
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by many to many relation fields: index 1`] = `
"export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { FloatWithAggregatesFilter } from \\"./FloatWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatWithAggregatesFilter } from \\"./NestedFloatWithAggregatesFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { RenamedFirstModelCreateInput } from \\"./RenamedFirstModelCreateInput\\";
export { RenamedFirstModelCreateManyInput } from \\"./RenamedFirstModelCreateManyInput\\";
export { RenamedFirstModelCreateNestedManyWithoutSecondModelsFieldInput } from \\"./RenamedFirstModelCreateNestedManyWithoutSecondModelsFieldInput\\";
export { RenamedFirstModelCreateOrConnectWithoutSecondModelsFieldInput } from \\"./RenamedFirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export { RenamedFirstModelCreateWithoutSecondModelsFieldInput } from \\"./RenamedFirstModelCreateWithoutSecondModelsFieldInput\\";
export { RenamedFirstModelListRelationFilter } from \\"./RenamedFirstModelListRelationFilter\\";
export { RenamedFirstModelOrderByInput } from \\"./RenamedFirstModelOrderByInput\\";
export { RenamedFirstModelScalarWhereInput } from \\"./RenamedFirstModelScalarWhereInput\\";
export { RenamedFirstModelScalarWhereWithAggregatesInput } from \\"./RenamedFirstModelScalarWhereWithAggregatesInput\\";
export { RenamedFirstModelUpdateInput } from \\"./RenamedFirstModelUpdateInput\\";
export { RenamedFirstModelUpdateManyMutationInput } from \\"./RenamedFirstModelUpdateManyMutationInput\\";
export { RenamedFirstModelUpdateManyWithWhereWithoutSecondModelsFieldInput } from \\"./RenamedFirstModelUpdateManyWithWhereWithoutSecondModelsFieldInput\\";
export { RenamedFirstModelUpdateManyWithoutSecondModelsFieldInput } from \\"./RenamedFirstModelUpdateManyWithoutSecondModelsFieldInput\\";
export { RenamedFirstModelUpdateWithWhereUniqueWithoutSecondModelsFieldInput } from \\"./RenamedFirstModelUpdateWithWhereUniqueWithoutSecondModelsFieldInput\\";
export { RenamedFirstModelUpdateWithoutSecondModelsFieldInput } from \\"./RenamedFirstModelUpdateWithoutSecondModelsFieldInput\\";
export { RenamedFirstModelUpsertWithWhereUniqueWithoutSecondModelsFieldInput } from \\"./RenamedFirstModelUpsertWithWhereUniqueWithoutSecondModelsFieldInput\\";
export { RenamedFirstModelWhereInput } from \\"./RenamedFirstModelWhereInput\\";
export { RenamedFirstModelWhereUniqueInput } from \\"./RenamedFirstModelWhereUniqueInput\\";
export { RenamedSecondModelCreateInput } from \\"./RenamedSecondModelCreateInput\\";
export { RenamedSecondModelCreateManyInput } from \\"./RenamedSecondModelCreateManyInput\\";
export { RenamedSecondModelCreateNestedManyWithoutFirstModelsFieldInput } from \\"./RenamedSecondModelCreateNestedManyWithoutFirstModelsFieldInput\\";
export { RenamedSecondModelCreateOrConnectWithoutFirstModelsFieldInput } from \\"./RenamedSecondModelCreateOrConnectWithoutFirstModelsFieldInput\\";
export { RenamedSecondModelCreateWithoutFirstModelsFieldInput } from \\"./RenamedSecondModelCreateWithoutFirstModelsFieldInput\\";
export { RenamedSecondModelListRelationFilter } from \\"./RenamedSecondModelListRelationFilter\\";
export { RenamedSecondModelOrderByInput } from \\"./RenamedSecondModelOrderByInput\\";
export { RenamedSecondModelScalarWhereInput } from \\"./RenamedSecondModelScalarWhereInput\\";
export { RenamedSecondModelScalarWhereWithAggregatesInput } from \\"./RenamedSecondModelScalarWhereWithAggregatesInput\\";
export { RenamedSecondModelUpdateInput } from \\"./RenamedSecondModelUpdateInput\\";
export { RenamedSecondModelUpdateManyMutationInput } from \\"./RenamedSecondModelUpdateManyMutationInput\\";
export { RenamedSecondModelUpdateManyWithWhereWithoutFirstModelsFieldInput } from \\"./RenamedSecondModelUpdateManyWithWhereWithoutFirstModelsFieldInput\\";
export { RenamedSecondModelUpdateManyWithoutFirstModelsFieldInput } from \\"./RenamedSecondModelUpdateManyWithoutFirstModelsFieldInput\\";
export { RenamedSecondModelUpdateWithWhereUniqueWithoutFirstModelsFieldInput } from \\"./RenamedSecondModelUpdateWithWhereUniqueWithoutFirstModelsFieldInput\\";
export { RenamedSecondModelUpdateWithoutFirstModelsFieldInput } from \\"./RenamedSecondModelUpdateWithoutFirstModelsFieldInput\\";
export { RenamedSecondModelUpsertWithWhereUniqueWithoutFirstModelsFieldInput } from \\"./RenamedSecondModelUpsertWithWhereUniqueWithoutFirstModelsFieldInput\\";
export { RenamedSecondModelWhereInput } from \\"./RenamedSecondModelWhereInput\\";
export { RenamedSecondModelWhereUniqueInput } from \\"./RenamedSecondModelWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: RenamedFirstModelOrderByInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class RenamedFirstModelOrderByInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
<<<<<<< HEAD
  otherId?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get intIdField() {
    return this.intIdField;
  }

  set intIdField(intIdField: \\"asc\\" | \\"desc\\" | undefined) {
    this.intIdField = intIdField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get stringField() {
    return this.stringField;
  }

  set stringField(stringField: \\"asc\\" | \\"desc\\" | undefined) {
    this.stringField = stringField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: \\"asc\\" | \\"desc\\" | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get booleanField() {
    return this.booleanField;
  }

  set booleanField(booleanField: \\"asc\\" | \\"desc\\" | undefined) {
    this.booleanField = booleanField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get dateField() {
    return this.dateField;
  }

  set dateField(dateField: \\"asc\\" | \\"desc\\" | undefined) {
    this.dateField = dateField;
  }

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  get otherId() {
    return this.otherId;
  }

  set otherId(otherId: \\"asc\\" | \\"desc\\" | undefined) {
    this.otherId = otherId;
  }
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes: ExampleWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { BoolFilter } from \\"../inputs/BoolFilter\\";
import { DateTimeFilter } from \\"../inputs/DateTimeFilter\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { OtherModelRelationFilter } from \\"../inputs/OtherModelRelationFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class ExampleWhereInput {
  @TypeGraphQL.Field(_type => [ExampleWhereInput], {
    nullable: true
  })
  AND?: ExampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [ExampleWhereInput], {
    nullable: true
  })
  OR?: ExampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [ExampleWhereInput], {
    nullable: true
  })
  NOT?: ExampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  intIdField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  stringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => BoolFilter, {
    nullable: true
  })
  booleanField?: BoolFilter | undefined;

  @TypeGraphQL.Field(_type => DateTimeFilter, {
    nullable: true
  })
  dateField?: DateTimeFilter | undefined;

  @TypeGraphQL.Field(_type => OtherModelRelationFilter, {
    nullable: true
  })
  other?: OtherModelRelationFilter | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  otherId?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => [ExampleWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: ExampleWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [ExampleWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: ExampleWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [ExampleWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: ExampleWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get intIdField() {
    return this.intIdField;
  }

  set intIdField(intIdField: IntFilter | undefined) {
    this.intIdField = intIdField;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get stringField() {
    return this.stringField;
  }

  set stringField(stringField: StringFilter | undefined) {
    this.stringField = stringField;
  }

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFilter | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => BoolFilter, {
    nullable: true
  })
  get booleanField() {
    return this.booleanField;
  }

  set booleanField(booleanField: BoolFilter | undefined) {
    this.booleanField = booleanField;
  }

  @TypeGraphQL.Field(_type => DateTimeFilter, {
    nullable: true
  })
  get dateField() {
    return this.dateField;
  }

  set dateField(dateField: DateTimeFilter | undefined) {
    this.dateField = dateField;
  }

  @TypeGraphQL.Field(_type => OtherModelRelationFilter, {
    nullable: true
  })
  get other() {
    return this.other;
  }

  set other(other: OtherModelRelationFilter | undefined) {
    this.other = other;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get otherId() {
    return this.otherId;
  }

  set otherId(otherId: IntFilter | undefined) {
    this.otherId = otherId;
  }
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes: ExampleWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class ExampleWhereUniqueInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  intIdField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  stringField?: string | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get intIdField() {
    return this.intIdField;
  }

  set intIdField(intIdField: number | undefined) {
    this.intIdField = intIdField;
  }

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  get stringField() {
    return this.stringField;
  }

  set stringField(stringField: string | undefined) {
    this.stringField = stringField;
  }
}
"
`;
=======
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: RenamedFirstModelRelationFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { RenamedFirstModelWhereInput } from \\"../inputs/RenamedFirstModelWhereInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class RenamedFirstModelRelationFilter {
  @TypeGraphQL.Field(_type => RenamedFirstModelWhereInput, {
    nullable: true
  })
  is?: RenamedFirstModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => RenamedFirstModelWhereInput, {
    nullable: true
  })
  isNot?: RenamedFirstModelWhereInput | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: RenamedFirstModelWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { RenamedSecondModelListRelationFilter } from \\"../inputs/RenamedSecondModelListRelationFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class RenamedFirstModelWhereInput {
  @TypeGraphQL.Field(_type => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  AND?: RenamedFirstModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  OR?: RenamedFirstModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  NOT?: RenamedFirstModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => RenamedSecondModelListRelationFilter, {
    nullable: true
  })
<<<<<<< HEAD
  jsonField?: JsonWithAggregatesFilter | undefined;

  @TypeGraphQL.Field(_type => [SampleScalarWhereWithAggregatesInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: SampleScalarWhereWithAggregatesInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [SampleScalarWhereWithAggregatesInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: SampleScalarWhereWithAggregatesInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [SampleScalarWhereWithAggregatesInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: SampleScalarWhereWithAggregatesInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => IntWithAggregatesFilter, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: IntWithAggregatesFilter | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => StringWithAggregatesFilter, {
    nullable: true
  })
  get stringField() {
    return this.stringField;
  }

  set stringField(stringField: StringWithAggregatesFilter | undefined) {
    this.stringField = stringField;
  }

  @TypeGraphQL.Field(_type => FloatWithAggregatesFilter, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatWithAggregatesFilter | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => IntWithAggregatesFilter, {
    nullable: true
  })
  get intField() {
    return this.intField;
  }

  set intField(intField: IntWithAggregatesFilter | undefined) {
    this.intField = intField;
  }

  @TypeGraphQL.Field(_type => BoolWithAggregatesFilter, {
    nullable: true
  })
  get booleanField() {
    return this.booleanField;
  }

  set booleanField(booleanField: BoolWithAggregatesFilter | undefined) {
    this.booleanField = booleanField;
  }

  @TypeGraphQL.Field(_type => DateTimeWithAggregatesFilter, {
    nullable: true
  })
  get dateField() {
    return this.dateField;
  }

  set dateField(dateField: DateTimeWithAggregatesFilter | undefined) {
    this.dateField = dateField;
  }

  @TypeGraphQL.Field(_type => JsonWithAggregatesFilter, {
    nullable: true
  })
  get jsonField() {
    return this.jsonField;
  }

  set jsonField(jsonField: JsonWithAggregatesFilter | undefined) {
    this.jsonField = jsonField;
  }
=======
  secondModelsField?: RenamedSecondModelListRelationFilter | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: RenamedFirstModelWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class RenamedFirstModelWhereUniqueInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  idField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
<<<<<<< HEAD
  max?: NestedBoolFilter | undefined;

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: boolean | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => NestedBoolWithAggregatesFilter, {
    nullable: true
  })
  get not() {
    return this.not;
  }

  set not(not: NestedBoolWithAggregatesFilter | undefined) {
    this.not = not;
  }

  @TypeGraphQL.Field(_type => NestedIntFilter, {
    nullable: true
  })
  get count() {
    return this.count;
  }

  set count(count: NestedIntFilter | undefined) {
    this.count = count;
  }

  @TypeGraphQL.Field(_type => NestedBoolFilter, {
    nullable: true
  })
  get min() {
    return this.min;
  }

  set min(min: NestedBoolFilter | undefined) {
    this.min = min;
  }

  @TypeGraphQL.Field(_type => NestedBoolFilter, {
    nullable: true
  })
  get max() {
    return this.max;
  }

  set max(max: NestedBoolFilter | undefined) {
    this.max = max;
  }
=======
  uniqueStringField?: string | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: RenamedSecondModelListRelationFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { RenamedSecondModelWhereInput } from \\"../inputs/RenamedSecondModelWhereInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class RenamedSecondModelListRelationFilter {
  @TypeGraphQL.Field(_type => RenamedSecondModelWhereInput, {
    nullable: true
  })
  every?: RenamedSecondModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => RenamedSecondModelWhereInput, {
    nullable: true
  })
  some?: RenamedSecondModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => RenamedSecondModelWhereInput, {
    nullable: true
  })
<<<<<<< HEAD
  max?: NestedDateTimeFilter | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: Date | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [Date], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: Date[] | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [Date], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: Date[] | undefined) {
  this.notIn = notIn;
}

@TypeGraphQL.Field(_type => Date, {
  nullable: true
})
get lt() {
  return this.lt;
}

set lt(lt: Date | undefined) {
  this.lt = lt;
}

@TypeGraphQL.Field(_type => Date, {
  nullable: true
})
get lte() {
  return this.lte;
}

set lte(lte: Date | undefined) {
  this.lte = lte;
}

@TypeGraphQL.Field(_type => Date, {
  nullable: true
})
get gt() {
  return this.gt;
}

set gt(gt: Date | undefined) {
  this.gt = gt;
}

@TypeGraphQL.Field(_type => Date, {
  nullable: true
})
get gte() {
  return this.gte;
}

set gte(gte: Date | undefined) {
  this.gte = gte;
}

@TypeGraphQL.Field(_type => NestedDateTimeWithAggregatesFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedDateTimeWithAggregatesFilter | undefined) {
  this.not = not;
}

@TypeGraphQL.Field(_type => NestedIntFilter, {
  nullable: true
})
get count() {
  return this.count;
}

set count(count: NestedIntFilter | undefined) {
  this.count = count;
}

@TypeGraphQL.Field(_type => NestedDateTimeFilter, {
  nullable: true
})
get min() {
  return this.min;
}

set min(min: NestedDateTimeFilter | undefined) {
  this.min = min;
}

@TypeGraphQL.Field(_type => NestedDateTimeFilter, {
  nullable: true
})
get max() {
  return this.max;
}

set max(max: NestedDateTimeFilter | undefined) {
  this.max = max;
}
=======
  none?: RenamedSecondModelWhereInput | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: RenamedSecondModelOrderByInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class RenamedSecondModelOrderByInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

<<<<<<< HEAD
  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  lte?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  gt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  gte?: number | undefined;

  @TypeGraphQL.Field(_type => NestedFloatWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedFloatWithAggregatesFilter | undefined;

  @TypeGraphQL.Field(_type => NestedIntFilter, {
    nullable: true
  })
  count?: NestedIntFilter | undefined;

  @TypeGraphQL.Field(_type => NestedFloatFilter, {
    nullable: true
  })
  avg?: NestedFloatFilter | undefined;

  @TypeGraphQL.Field(_type => NestedFloatFilter, {
    nullable: true
  })
  sum?: NestedFloatFilter | undefined;

  @TypeGraphQL.Field(_type => NestedFloatFilter, {
    nullable: true
  })
  min?: NestedFloatFilter | undefined;

  @TypeGraphQL.Field(_type => NestedFloatFilter, {
    nullable: true
  })
  max?: NestedFloatFilter | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: number | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [TypeGraphQL.Float], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: number[] | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [TypeGraphQL.Float], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: number[] | undefined) {
  this.notIn = notIn;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Float, {
  nullable: true
})
get lt() {
  return this.lt;
}

set lt(lt: number | undefined) {
  this.lt = lt;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Float, {
  nullable: true
})
get lte() {
  return this.lte;
}

set lte(lte: number | undefined) {
  this.lte = lte;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Float, {
  nullable: true
})
get gt() {
  return this.gt;
}

set gt(gt: number | undefined) {
  this.gt = gt;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Float, {
  nullable: true
})
get gte() {
  return this.gte;
}

set gte(gte: number | undefined) {
  this.gte = gte;
}

@TypeGraphQL.Field(_type => NestedFloatWithAggregatesFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedFloatWithAggregatesFilter | undefined) {
  this.not = not;
}

@TypeGraphQL.Field(_type => NestedIntFilter, {
  nullable: true
})
get count() {
  return this.count;
}

set count(count: NestedIntFilter | undefined) {
  this.count = count;
}

@TypeGraphQL.Field(_type => NestedFloatFilter, {
  nullable: true
})
get avg() {
  return this.avg;
}

set avg(avg: NestedFloatFilter | undefined) {
  this.avg = avg;
}

@TypeGraphQL.Field(_type => NestedFloatFilter, {
  nullable: true
})
get sum() {
  return this.sum;
}

set sum(sum: NestedFloatFilter | undefined) {
  this.sum = sum;
}

@TypeGraphQL.Field(_type => NestedFloatFilter, {
  nullable: true
})
get min() {
  return this.min;
}

set min(min: NestedFloatFilter | undefined) {
  this.min = min;
}

@TypeGraphQL.Field(_type => NestedFloatFilter, {
  nullable: true
})
get max() {
  return this.max;
}

set max(max: NestedFloatFilter | undefined) {
  this.max = max;
}
=======
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  firstModelFieldId?: \\"asc\\" | \\"desc\\" | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: RenamedSecondModelScalarWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class RenamedSecondModelScalarWhereInput {
  @TypeGraphQL.Field(_type => [RenamedSecondModelScalarWhereInput], {
    nullable: true
  })
  AND?: RenamedSecondModelScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [RenamedSecondModelScalarWhereInput], {
    nullable: true
  })
  OR?: RenamedSecondModelScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [RenamedSecondModelScalarWhereInput], {
    nullable: true
  })
  NOT?: RenamedSecondModelScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  firstModelFieldId?: IntFilter | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: RenamedSecondModelWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { RenamedFirstModelRelationFilter } from \\"../inputs/RenamedFirstModelRelationFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class RenamedSecondModelWhereInput {
  @TypeGraphQL.Field(_type => [RenamedSecondModelWhereInput], {
    nullable: true
  })
  AND?: RenamedSecondModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [RenamedSecondModelWhereInput], {
    nullable: true
  })
  OR?: RenamedSecondModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [RenamedSecondModelWhereInput], {
    nullable: true
  })
  NOT?: RenamedSecondModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  firstModelFieldId?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => RenamedFirstModelRelationFilter, {
    nullable: true
  })
  firstModelField?: RenamedFirstModelRelationFilter | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: RenamedSecondModelWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class RenamedSecondModelWhereUniqueInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  idField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
<<<<<<< HEAD
  max?: NestedIntFilter | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: number | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: number[] | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: number[] | undefined) {
  this.notIn = notIn;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Int, {
  nullable: true
})
get lt() {
  return this.lt;
}

set lt(lt: number | undefined) {
  this.lt = lt;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Int, {
  nullable: true
})
get lte() {
  return this.lte;
}

set lte(lte: number | undefined) {
  this.lte = lte;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Int, {
  nullable: true
})
get gt() {
  return this.gt;
}

set gt(gt: number | undefined) {
  this.gt = gt;
}

@TypeGraphQL.Field(_type => TypeGraphQL.Int, {
  nullable: true
})
get gte() {
  return this.gte;
}

set gte(gte: number | undefined) {
  this.gte = gte;
}

@TypeGraphQL.Field(_type => NestedIntWithAggregatesFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedIntWithAggregatesFilter | undefined) {
  this.not = not;
}

@TypeGraphQL.Field(_type => NestedIntFilter, {
  nullable: true
})
get count() {
  return this.count;
}

set count(count: NestedIntFilter | undefined) {
  this.count = count;
}

@TypeGraphQL.Field(_type => NestedFloatFilter, {
  nullable: true
})
get avg() {
  return this.avg;
}

set avg(avg: NestedFloatFilter | undefined) {
  this.avg = avg;
}

@TypeGraphQL.Field(_type => NestedIntFilter, {
  nullable: true
})
get sum() {
  return this.sum;
}

set sum(sum: NestedIntFilter | undefined) {
  this.sum = sum;
}

@TypeGraphQL.Field(_type => NestedIntFilter, {
  nullable: true
})
get min() {
  return this.min;
}

set min(min: NestedIntFilter | undefined) {
  this.min = min;
}

@TypeGraphQL.Field(_type => NestedIntFilter, {
  nullable: true
})
get max() {
  return this.max;
}

set max(max: NestedIntFilter | undefined) {
  this.max = max;
}
=======
  uniqueStringField?: string | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: index 1`] = `
"export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { FloatWithAggregatesFilter } from \\"./FloatWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatWithAggregatesFilter } from \\"./NestedFloatWithAggregatesFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { RenamedFirstModelCreateInput } from \\"./RenamedFirstModelCreateInput\\";
export { RenamedFirstModelCreateManyInput } from \\"./RenamedFirstModelCreateManyInput\\";
export { RenamedFirstModelCreateNestedOneWithoutSecondModelsFieldInput } from \\"./RenamedFirstModelCreateNestedOneWithoutSecondModelsFieldInput\\";
export { RenamedFirstModelCreateOrConnectWithoutSecondModelsFieldInput } from \\"./RenamedFirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export { RenamedFirstModelCreateWithoutSecondModelsFieldInput } from \\"./RenamedFirstModelCreateWithoutSecondModelsFieldInput\\";
export { RenamedFirstModelOrderByInput } from \\"./RenamedFirstModelOrderByInput\\";
export { RenamedFirstModelRelationFilter } from \\"./RenamedFirstModelRelationFilter\\";
export { RenamedFirstModelScalarWhereWithAggregatesInput } from \\"./RenamedFirstModelScalarWhereWithAggregatesInput\\";
export { RenamedFirstModelUpdateInput } from \\"./RenamedFirstModelUpdateInput\\";
export { RenamedFirstModelUpdateManyMutationInput } from \\"./RenamedFirstModelUpdateManyMutationInput\\";
export { RenamedFirstModelUpdateOneRequiredWithoutSecondModelsFieldInput } from \\"./RenamedFirstModelUpdateOneRequiredWithoutSecondModelsFieldInput\\";
export { RenamedFirstModelUpdateWithoutSecondModelsFieldInput } from \\"./RenamedFirstModelUpdateWithoutSecondModelsFieldInput\\";
export { RenamedFirstModelUpsertWithoutSecondModelsFieldInput } from \\"./RenamedFirstModelUpsertWithoutSecondModelsFieldInput\\";
export { RenamedFirstModelWhereInput } from \\"./RenamedFirstModelWhereInput\\";
export { RenamedFirstModelWhereUniqueInput } from \\"./RenamedFirstModelWhereUniqueInput\\";
export { RenamedSecondModelCreateInput } from \\"./RenamedSecondModelCreateInput\\";
export { RenamedSecondModelCreateManyFirstModelFieldInput } from \\"./RenamedSecondModelCreateManyFirstModelFieldInput\\";
export { RenamedSecondModelCreateManyFirstModelFieldInputEnvelope } from \\"./RenamedSecondModelCreateManyFirstModelFieldInputEnvelope\\";
export { RenamedSecondModelCreateManyInput } from \\"./RenamedSecondModelCreateManyInput\\";
export { RenamedSecondModelCreateNestedManyWithoutFirstModelFieldInput } from \\"./RenamedSecondModelCreateNestedManyWithoutFirstModelFieldInput\\";
export { RenamedSecondModelCreateOrConnectWithoutFirstModelFieldInput } from \\"./RenamedSecondModelCreateOrConnectWithoutFirstModelFieldInput\\";
export { RenamedSecondModelCreateWithoutFirstModelFieldInput } from \\"./RenamedSecondModelCreateWithoutFirstModelFieldInput\\";
export { RenamedSecondModelListRelationFilter } from \\"./RenamedSecondModelListRelationFilter\\";
export { RenamedSecondModelOrderByInput } from \\"./RenamedSecondModelOrderByInput\\";
export { RenamedSecondModelScalarWhereInput } from \\"./RenamedSecondModelScalarWhereInput\\";
export { RenamedSecondModelScalarWhereWithAggregatesInput } from \\"./RenamedSecondModelScalarWhereWithAggregatesInput\\";
export { RenamedSecondModelUpdateInput } from \\"./RenamedSecondModelUpdateInput\\";
export { RenamedSecondModelUpdateManyMutationInput } from \\"./RenamedSecondModelUpdateManyMutationInput\\";
export { RenamedSecondModelUpdateManyWithWhereWithoutFirstModelFieldInput } from \\"./RenamedSecondModelUpdateManyWithWhereWithoutFirstModelFieldInput\\";
export { RenamedSecondModelUpdateManyWithoutFirstModelFieldInput } from \\"./RenamedSecondModelUpdateManyWithoutFirstModelFieldInput\\";
export { RenamedSecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput } from \\"./RenamedSecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput\\";
export { RenamedSecondModelUpdateWithoutFirstModelFieldInput } from \\"./RenamedSecondModelUpdateWithoutFirstModelFieldInput\\";
export { RenamedSecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput } from \\"./RenamedSecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput\\";
export { RenamedSecondModelWhereInput } from \\"./RenamedSecondModelWhereInput\\";
export { RenamedSecondModelWhereUniqueInput } from \\"./RenamedSecondModelWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs when model is renamed should properly generate input type classes: ExampleOrderByInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class ExampleOrderByInput {
  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  intIdField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  stringField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  booleanField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
  dateField?: \\"asc\\" | \\"desc\\" | undefined;

  @TypeGraphQL.Field(_type => SortOrder, {
    nullable: true
  })
<<<<<<< HEAD
  max?: NestedJsonFilter | undefined;

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: Prisma.InputJsonValue | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  get not() {
    return this.not;
  }

  set not(not: Prisma.InputJsonValue | undefined) {
    this.not = not;
  }

  @TypeGraphQL.Field(_type => NestedIntFilter, {
    nullable: true
  })
  get count() {
    return this.count;
  }

  set count(count: NestedIntFilter | undefined) {
    this.count = count;
  }

  @TypeGraphQL.Field(_type => NestedJsonFilter, {
    nullable: true
  })
  get min() {
    return this.min;
  }

  set min(min: NestedJsonFilter | undefined) {
    this.min = min;
  }

  @TypeGraphQL.Field(_type => NestedJsonFilter, {
    nullable: true
  })
  get max() {
    return this.max;
  }

  set max(max: NestedJsonFilter | undefined) {
    this.max = max;
  }
=======
  otherId?: \\"asc\\" | \\"desc\\" | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes: ExampleWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { BoolFilter } from \\"../inputs/BoolFilter\\";
import { DateTimeFilter } from \\"../inputs/DateTimeFilter\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { OtherModelRelationFilter } from \\"../inputs/OtherModelRelationFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class ExampleWhereInput {
  @TypeGraphQL.Field(_type => [ExampleWhereInput], {
    nullable: true
  })
  AND?: ExampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [ExampleWhereInput], {
    nullable: true
  })
  OR?: ExampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [ExampleWhereInput], {
    nullable: true
  })
  NOT?: ExampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  intIdField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  stringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => BoolFilter, {
    nullable: true
  })
  booleanField?: BoolFilter | undefined;

  @TypeGraphQL.Field(_type => DateTimeFilter, {
    nullable: true
  })
  dateField?: DateTimeFilter | undefined;

  @TypeGraphQL.Field(_type => OtherModelRelationFilter, {
    nullable: true
  })
  other?: OtherModelRelationFilter | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  otherId?: IntFilter | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes: ExampleWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class ExampleWhereUniqueInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  intIdField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
<<<<<<< HEAD
  max?: NestedStringFilter | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true
  })
  get equals() {
    return this.equals;
  }

  set equals(equals: string | undefined) {
    this.equals = equals;
  }

  @TypeGraphQL.Field(_type => [String], {
    nullable: true
  })
  get in() {
    return this.in;
  }

  set in(in: string[] | undefined) {
  this.in = in;
}

@TypeGraphQL.Field(_type => [String], {
  nullable: true
})
get notIn() {
  return this.notIn;
}

set notIn(notIn: string[] | undefined) {
  this.notIn = notIn;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get lt() {
  return this.lt;
}

set lt(lt: string | undefined) {
  this.lt = lt;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get lte() {
  return this.lte;
}

set lte(lte: string | undefined) {
  this.lte = lte;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get gt() {
  return this.gt;
}

set gt(gt: string | undefined) {
  this.gt = gt;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get gte() {
  return this.gte;
}

set gte(gte: string | undefined) {
  this.gte = gte;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get contains() {
  return this.contains;
}

set contains(contains: string | undefined) {
  this.contains = contains;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get startsWith() {
  return this.startsWith;
}

set startsWith(startsWith: string | undefined) {
  this.startsWith = startsWith;
}

@TypeGraphQL.Field(_type => String, {
  nullable: true
})
get endsWith() {
  return this.endsWith;
}

set endsWith(endsWith: string | undefined) {
  this.endsWith = endsWith;
}

@TypeGraphQL.Field(_type => QueryMode, {
  nullable: true
})
get mode() {
  return this.mode;
}

set mode(mode: \\"default\\" | \\"insensitive\\" | undefined) {
  this.mode = mode;
}

@TypeGraphQL.Field(_type => NestedStringWithAggregatesFilter, {
  nullable: true
})
get not() {
  return this.not;
}

set not(not: NestedStringWithAggregatesFilter | undefined) {
  this.not = not;
}

@TypeGraphQL.Field(_type => NestedIntFilter, {
  nullable: true
})
get count() {
  return this.count;
}

set count(count: NestedIntFilter | undefined) {
  this.count = count;
}

@TypeGraphQL.Field(_type => NestedStringFilter, {
  nullable: true
})
get min() {
  return this.min;
}

set min(min: NestedStringFilter | undefined) {
  this.min = min;
}

@TypeGraphQL.Field(_type => NestedStringFilter, {
  nullable: true
})
get max() {
  return this.max;
}

set max(max: NestedStringFilter | undefined) {
  this.max = max;
}
=======
  stringField?: string | undefined;
>>>>>>> 00641fdc6fcd347db5ea77a4c9470d59a6ea458e
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes: index 1`] = `
"export { BoolFieldUpdateOperationsInput } from \\"./BoolFieldUpdateOperationsInput\\";
export { BoolFilter } from \\"./BoolFilter\\";
export { BoolWithAggregatesFilter } from \\"./BoolWithAggregatesFilter\\";
export { DateTimeFieldUpdateOperationsInput } from \\"./DateTimeFieldUpdateOperationsInput\\";
export { DateTimeFilter } from \\"./DateTimeFilter\\";
export { DateTimeWithAggregatesFilter } from \\"./DateTimeWithAggregatesFilter\\";
export { ExampleCreateInput } from \\"./ExampleCreateInput\\";
export { ExampleCreateManyInput } from \\"./ExampleCreateManyInput\\";
export { ExampleCreateManyOtherInput } from \\"./ExampleCreateManyOtherInput\\";
export { ExampleCreateManyOtherInputEnvelope } from \\"./ExampleCreateManyOtherInputEnvelope\\";
export { ExampleCreateNestedManyWithoutOtherInput } from \\"./ExampleCreateNestedManyWithoutOtherInput\\";
export { ExampleCreateOrConnectWithoutOtherInput } from \\"./ExampleCreateOrConnectWithoutOtherInput\\";
export { ExampleCreateWithoutOtherInput } from \\"./ExampleCreateWithoutOtherInput\\";
export { ExampleListRelationFilter } from \\"./ExampleListRelationFilter\\";
export { ExampleOrderByInput } from \\"./ExampleOrderByInput\\";
export { ExampleScalarWhereInput } from \\"./ExampleScalarWhereInput\\";
export { ExampleScalarWhereWithAggregatesInput } from \\"./ExampleScalarWhereWithAggregatesInput\\";
export { ExampleUpdateInput } from \\"./ExampleUpdateInput\\";
export { ExampleUpdateManyMutationInput } from \\"./ExampleUpdateManyMutationInput\\";
export { ExampleUpdateManyWithWhereWithoutOtherInput } from \\"./ExampleUpdateManyWithWhereWithoutOtherInput\\";
export { ExampleUpdateManyWithoutOtherInput } from \\"./ExampleUpdateManyWithoutOtherInput\\";
export { ExampleUpdateWithWhereUniqueWithoutOtherInput } from \\"./ExampleUpdateWithWhereUniqueWithoutOtherInput\\";
export { ExampleUpdateWithoutOtherInput } from \\"./ExampleUpdateWithoutOtherInput\\";
export { ExampleUpsertWithWhereUniqueWithoutOtherInput } from \\"./ExampleUpsertWithWhereUniqueWithoutOtherInput\\";
export { ExampleWhereInput } from \\"./ExampleWhereInput\\";
export { ExampleWhereUniqueInput } from \\"./ExampleWhereUniqueInput\\";
export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { FloatWithAggregatesFilter } from \\"./FloatWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { NestedBoolFilter } from \\"./NestedBoolFilter\\";
export { NestedBoolWithAggregatesFilter } from \\"./NestedBoolWithAggregatesFilter\\";
export { NestedDateTimeFilter } from \\"./NestedDateTimeFilter\\";
export { NestedDateTimeWithAggregatesFilter } from \\"./NestedDateTimeWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatWithAggregatesFilter } from \\"./NestedFloatWithAggregatesFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { OtherModelCreateInput } from \\"./OtherModelCreateInput\\";
export { OtherModelCreateManyInput } from \\"./OtherModelCreateManyInput\\";
export { OtherModelCreateNestedOneWithoutSampleModelInput } from \\"./OtherModelCreateNestedOneWithoutSampleModelInput\\";
export { OtherModelCreateOrConnectWithoutSampleModelInput } from \\"./OtherModelCreateOrConnectWithoutSampleModelInput\\";
export { OtherModelCreateWithoutSampleModelInput } from \\"./OtherModelCreateWithoutSampleModelInput\\";
export { OtherModelOrderByInput } from \\"./OtherModelOrderByInput\\";
export { OtherModelRelationFilter } from \\"./OtherModelRelationFilter\\";
export { OtherModelScalarWhereWithAggregatesInput } from \\"./OtherModelScalarWhereWithAggregatesInput\\";
export { OtherModelUpdateInput } from \\"./OtherModelUpdateInput\\";
export { OtherModelUpdateManyMutationInput } from \\"./OtherModelUpdateManyMutationInput\\";
export { OtherModelUpdateOneRequiredWithoutSampleModelInput } from \\"./OtherModelUpdateOneRequiredWithoutSampleModelInput\\";
export { OtherModelUpdateWithoutSampleModelInput } from \\"./OtherModelUpdateWithoutSampleModelInput\\";
export { OtherModelUpsertWithoutSampleModelInput } from \\"./OtherModelUpsertWithoutSampleModelInput\\";
export { OtherModelWhereInput } from \\"./OtherModelWhereInput\\";
export { OtherModelWhereUniqueInput } from \\"./OtherModelWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs when prisma client is generated into node_modules should properly generate prisma client imports in input type class files: SampleWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"@prisma/client\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class SampleWhereInput {
  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true
  })
  AND?: SampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true
  })
  OR?: SampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true
  })
  NOT?: SampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  modelFieldName?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true
  })
  get AND() {
    return this.AND;
  }

  set AND(AND: SampleWhereInput[] | undefined) {
    this.AND = AND;
  }

  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true
  })
  get OR() {
    return this.OR;
  }

  set OR(OR: SampleWhereInput[] | undefined) {
    this.OR = OR;
  }

  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true
  })
  get NOT() {
    return this.NOT;
  }

  set NOT(NOT: SampleWhereInput[] | undefined) {
    this.NOT = NOT;
  }

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: IntFilter | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true
  })
  get modelFieldName() {
    return this.modelFieldName;
  }

  set modelFieldName(modelFieldName: StringFilter | undefined) {
    this.modelFieldName = modelFieldName;
  }
}
"
`;

exports[`inputs when prisma client is generated into node_modules should properly generate prisma client imports in input type class files: index 1`] = `
"export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { SampleCreateInput } from \\"./SampleCreateInput\\";
export { SampleCreateManyInput } from \\"./SampleCreateManyInput\\";
export { SampleOrderByInput } from \\"./SampleOrderByInput\\";
export { SampleScalarWhereWithAggregatesInput } from \\"./SampleScalarWhereWithAggregatesInput\\";
export { SampleUpdateInput } from \\"./SampleUpdateInput\\";
export { SampleUpdateManyMutationInput } from \\"./SampleUpdateManyMutationInput\\";
export { SampleWhereInput } from \\"./SampleWhereInput\\";
export { SampleWhereUniqueInput } from \\"./SampleWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelCreateNestedOneWithoutSecondModelsFieldInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelCreateOrConnectWithoutSecondModelsFieldInput } from \\"../inputs/FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
import { FirstModelUncheckedCreateWithoutSecondModelsFieldInput } from \\"../inputs/FirstModelUncheckedCreateWithoutSecondModelsFieldInput\\";
import { FirstModelWhereUniqueInput } from \\"../inputs/FirstModelWhereUniqueInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelCreateNestedOneWithoutSecondModelsFieldInput {
  @TypeGraphQL.Field(_type => FirstModelUncheckedCreateWithoutSecondModelsFieldInput, {
    nullable: true
  })
  create?: FirstModelUncheckedCreateWithoutSecondModelsFieldInput | undefined;

  @TypeGraphQL.Field(_type => FirstModelCreateOrConnectWithoutSecondModelsFieldInput, {
    nullable: true
  })
  connectOrCreate?: FirstModelCreateOrConnectWithoutSecondModelsFieldInput | undefined;

  @TypeGraphQL.Field(_type => FirstModelWhereUniqueInput, {
    nullable: true
  })
  connect?: FirstModelWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => FirstModelUncheckedCreateWithoutSecondModelsFieldInput, {
    nullable: true
  })
  get create() {
    return this.create;
  }

  set create(create: FirstModelUncheckedCreateWithoutSecondModelsFieldInput | undefined) {
    this.create = create;
  }

  @TypeGraphQL.Field(_type => FirstModelCreateOrConnectWithoutSecondModelsFieldInput, {
    nullable: true
  })
  get connectOrCreate() {
    return this.connectOrCreate;
  }

  set connectOrCreate(connectOrCreate: FirstModelCreateOrConnectWithoutSecondModelsFieldInput | undefined) {
    this.connectOrCreate = connectOrCreate;
  }

  @TypeGraphQL.Field(_type => FirstModelWhereUniqueInput, {
    nullable: true
  })
  get connect() {
    return this.connect;
  }

  set connect(connect: FirstModelWhereUniqueInput | undefined) {
    this.connect = connect;
  }
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelCreateOrConnectWithoutSecondModelsFieldInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelUncheckedCreateWithoutSecondModelsFieldInput } from \\"../inputs/FirstModelUncheckedCreateWithoutSecondModelsFieldInput\\";
import { FirstModelWhereUniqueInput } from \\"../inputs/FirstModelWhereUniqueInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelCreateOrConnectWithoutSecondModelsFieldInput {
  @TypeGraphQL.Field(_type => FirstModelWhereUniqueInput, {
    nullable: false
  })
  where!: FirstModelWhereUniqueInput;

  @TypeGraphQL.Field(_type => FirstModelUncheckedCreateWithoutSecondModelsFieldInput, {
    nullable: false
  })
  create!: FirstModelUncheckedCreateWithoutSecondModelsFieldInput;

  @TypeGraphQL.Field(_type => FirstModelWhereUniqueInput, {
    nullable: false
  })
  get where() {
    return this.where;
  }

  set where(where: FirstModelWhereUniqueInput) {
    this.where = where;
  }

  @TypeGraphQL.Field(_type => FirstModelUncheckedCreateWithoutSecondModelsFieldInput, {
    nullable: false
  })
  get create() {
    return this.create;
  }

  set create(create: FirstModelUncheckedCreateWithoutSecondModelsFieldInput) {
    this.create = create;
  }
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelCreateWithoutSecondModelsFieldInputTSFile 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelCreateWithoutSecondModelsFieldInput {
  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  uniqueStringField!: string;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: false
  })
  floatField!: number;

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: string) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: false
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: number) {
    this.floatField = floatField;
  }
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelUncheckedCreateInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SecondModelUncheckedCreateNestedManyWithoutFirstModelFieldInput } from \\"../inputs/SecondModelUncheckedCreateNestedManyWithoutFirstModelFieldInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelUncheckedCreateInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  idField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  uniqueStringField!: string;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: false
  })
  floatField!: number;

  @TypeGraphQL.Field(_type => SecondModelUncheckedCreateNestedManyWithoutFirstModelFieldInput, {
    nullable: true
  })
  secondModelsField?: SecondModelUncheckedCreateNestedManyWithoutFirstModelFieldInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: number | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: string) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: false
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: number) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => SecondModelUncheckedCreateNestedManyWithoutFirstModelFieldInput, {
    nullable: true
  })
  get secondModelsField() {
    return this.secondModelsField;
  }

  set secondModelsField(secondModelsField: SecondModelUncheckedCreateNestedManyWithoutFirstModelFieldInput | undefined) {
    this.secondModelsField = secondModelsField;
  }
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelUncheckedCreateWithoutSecondModelsFieldInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelUncheckedCreateWithoutSecondModelsFieldInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  idField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  uniqueStringField!: string;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: false
  })
  floatField!: number;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: number | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: string) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: false
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: number) {
    this.floatField = floatField;
  }
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelUncheckedUpdateInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFieldUpdateOperationsInput } from \\"../inputs/FloatFieldUpdateOperationsInput\\";
import { IntFieldUpdateOperationsInput } from \\"../inputs/IntFieldUpdateOperationsInput\\";
import { SecondModelUncheckedUpdateManyWithoutFirstModelFieldInput } from \\"../inputs/SecondModelUncheckedUpdateManyWithoutFirstModelFieldInput\\";
import { StringFieldUpdateOperationsInput } from \\"../inputs/StringFieldUpdateOperationsInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelUncheckedUpdateInput {
  @TypeGraphQL.Field(_type => IntFieldUpdateOperationsInput, {
    nullable: true
  })
  idField?: IntFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  uniqueStringField?: StringFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  floatField?: FloatFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => SecondModelUncheckedUpdateManyWithoutFirstModelFieldInput, {
    nullable: true
  })
  secondModelsField?: SecondModelUncheckedUpdateManyWithoutFirstModelFieldInput | undefined;

  @TypeGraphQL.Field(_type => IntFieldUpdateOperationsInput, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: IntFieldUpdateOperationsInput | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: StringFieldUpdateOperationsInput | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFieldUpdateOperationsInput | undefined) {
    this.floatField = floatField;
  }

  @TypeGraphQL.Field(_type => SecondModelUncheckedUpdateManyWithoutFirstModelFieldInput, {
    nullable: true
  })
  get secondModelsField() {
    return this.secondModelsField;
  }

  set secondModelsField(secondModelsField: SecondModelUncheckedUpdateManyWithoutFirstModelFieldInput | undefined) {
    this.secondModelsField = secondModelsField;
  }
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelUncheckedUpdateManyInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFieldUpdateOperationsInput } from \\"../inputs/FloatFieldUpdateOperationsInput\\";
import { IntFieldUpdateOperationsInput } from \\"../inputs/IntFieldUpdateOperationsInput\\";
import { StringFieldUpdateOperationsInput } from \\"../inputs/StringFieldUpdateOperationsInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelUncheckedUpdateManyInput {
  @TypeGraphQL.Field(_type => IntFieldUpdateOperationsInput, {
    nullable: true
  })
  idField?: IntFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  uniqueStringField?: StringFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  floatField?: FloatFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => IntFieldUpdateOperationsInput, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: IntFieldUpdateOperationsInput | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: StringFieldUpdateOperationsInput | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFieldUpdateOperationsInput | undefined) {
    this.floatField = floatField;
  }
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelUncheckedUpdateWithoutSecondModelsFieldInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFieldUpdateOperationsInput } from \\"../inputs/FloatFieldUpdateOperationsInput\\";
import { IntFieldUpdateOperationsInput } from \\"../inputs/IntFieldUpdateOperationsInput\\";
import { StringFieldUpdateOperationsInput } from \\"../inputs/StringFieldUpdateOperationsInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelUncheckedUpdateWithoutSecondModelsFieldInput {
  @TypeGraphQL.Field(_type => IntFieldUpdateOperationsInput, {
    nullable: true
  })
  idField?: IntFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  uniqueStringField?: StringFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  floatField?: FloatFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => IntFieldUpdateOperationsInput, {
    nullable: true
  })
  get idField() {
    return this.idField;
  }

  set idField(idField: IntFieldUpdateOperationsInput | undefined) {
    this.idField = idField;
  }

  @TypeGraphQL.Field(_type => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: StringFieldUpdateOperationsInput | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFieldUpdateOperationsInput | undefined) {
    this.floatField = floatField;
  }
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelUpdateOneRequiredWithoutSecondModelsFieldInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelCreateOrConnectWithoutSecondModelsFieldInput } from \\"../inputs/FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
import { FirstModelUncheckedCreateWithoutSecondModelsFieldInput } from \\"../inputs/FirstModelUncheckedCreateWithoutSecondModelsFieldInput\\";
import { FirstModelUncheckedUpdateWithoutSecondModelsFieldInput } from \\"../inputs/FirstModelUncheckedUpdateWithoutSecondModelsFieldInput\\";
import { FirstModelUpsertWithoutSecondModelsFieldInput } from \\"../inputs/FirstModelUpsertWithoutSecondModelsFieldInput\\";
import { FirstModelWhereUniqueInput } from \\"../inputs/FirstModelWhereUniqueInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelUpdateOneRequiredWithoutSecondModelsFieldInput {
  @TypeGraphQL.Field(_type => FirstModelUncheckedCreateWithoutSecondModelsFieldInput, {
    nullable: true
  })
  create?: FirstModelUncheckedCreateWithoutSecondModelsFieldInput | undefined;

  @TypeGraphQL.Field(_type => FirstModelCreateOrConnectWithoutSecondModelsFieldInput, {
    nullable: true
  })
  connectOrCreate?: FirstModelCreateOrConnectWithoutSecondModelsFieldInput | undefined;

  @TypeGraphQL.Field(_type => FirstModelUpsertWithoutSecondModelsFieldInput, {
    nullable: true
  })
  upsert?: FirstModelUpsertWithoutSecondModelsFieldInput | undefined;

  @TypeGraphQL.Field(_type => FirstModelWhereUniqueInput, {
    nullable: true
  })
  connect?: FirstModelWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => FirstModelUncheckedUpdateWithoutSecondModelsFieldInput, {
    nullable: true
  })
  update?: FirstModelUncheckedUpdateWithoutSecondModelsFieldInput | undefined;

  @TypeGraphQL.Field(_type => FirstModelUncheckedCreateWithoutSecondModelsFieldInput, {
    nullable: true
  })
  get create() {
    return this.create;
  }

  set create(create: FirstModelUncheckedCreateWithoutSecondModelsFieldInput | undefined) {
    this.create = create;
  }

  @TypeGraphQL.Field(_type => FirstModelCreateOrConnectWithoutSecondModelsFieldInput, {
    nullable: true
  })
  get connectOrCreate() {
    return this.connectOrCreate;
  }

  set connectOrCreate(connectOrCreate: FirstModelCreateOrConnectWithoutSecondModelsFieldInput | undefined) {
    this.connectOrCreate = connectOrCreate;
  }

  @TypeGraphQL.Field(_type => FirstModelUpsertWithoutSecondModelsFieldInput, {
    nullable: true
  })
  get upsert() {
    return this.upsert;
  }

  set upsert(upsert: FirstModelUpsertWithoutSecondModelsFieldInput | undefined) {
    this.upsert = upsert;
  }

  @TypeGraphQL.Field(_type => FirstModelWhereUniqueInput, {
    nullable: true
  })
  get connect() {
    return this.connect;
  }

  set connect(connect: FirstModelWhereUniqueInput | undefined) {
    this.connect = connect;
  }

  @TypeGraphQL.Field(_type => FirstModelUncheckedUpdateWithoutSecondModelsFieldInput, {
    nullable: true
  })
  get update() {
    return this.update;
  }

  set update(update: FirstModelUncheckedUpdateWithoutSecondModelsFieldInput | undefined) {
    this.update = update;
  }
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelUpdateWithoutSecondModelsFieldInputTSFile 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFieldUpdateOperationsInput } from \\"../inputs/FloatFieldUpdateOperationsInput\\";
import { StringFieldUpdateOperationsInput } from \\"../inputs/StringFieldUpdateOperationsInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelUpdateWithoutSecondModelsFieldInput {
  @TypeGraphQL.Field(_type => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  uniqueStringField?: StringFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  floatField?: FloatFieldUpdateOperationsInput | undefined;

  @TypeGraphQL.Field(_type => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  get uniqueStringField() {
    return this.uniqueStringField;
  }

  set uniqueStringField(uniqueStringField: StringFieldUpdateOperationsInput | undefined) {
    this.uniqueStringField = uniqueStringField;
  }

  @TypeGraphQL.Field(_type => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  get floatField() {
    return this.floatField;
  }

  set floatField(floatField: FloatFieldUpdateOperationsInput | undefined) {
    this.floatField = floatField;
  }
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelUpsertWithoutSecondModelsFieldInputTSFile 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelUncheckedCreateWithoutSecondModelsFieldInput } from \\"../inputs/FirstModelUncheckedCreateWithoutSecondModelsFieldInput\\";
import { FirstModelUncheckedUpdateWithoutSecondModelsFieldInput } from \\"../inputs/FirstModelUncheckedUpdateWithoutSecondModelsFieldInput\\";

@TypeGraphQL.InputType({
  isAbstract: true
})
export class FirstModelUpsertWithoutSecondModelsFieldInput {
  @TypeGraphQL.Field(_type => FirstModelUncheckedUpdateWithoutSecondModelsFieldInput, {
    nullable: false
  })
  update!: FirstModelUncheckedUpdateWithoutSecondModelsFieldInput;

  @TypeGraphQL.Field(_type => FirstModelUncheckedCreateWithoutSecondModelsFieldInput, {
    nullable: false
  })
  create!: FirstModelUncheckedCreateWithoutSecondModelsFieldInput;

  @TypeGraphQL.Field(_type => FirstModelUncheckedUpdateWithoutSecondModelsFieldInput, {
    nullable: false
  })
  get update() {
    return this.update;
  }

  set update(update: FirstModelUncheckedUpdateWithoutSecondModelsFieldInput) {
    this.update = update;
  }

  @TypeGraphQL.Field(_type => FirstModelUncheckedCreateWithoutSecondModelsFieldInput, {
    nullable: false
  })
  get create() {
    return this.create;
  }

  set create(create: FirstModelUncheckedCreateWithoutSecondModelsFieldInput) {
    this.create = create;
  }
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: index 1`] = `
"export { FirstModelCreateInput } from \\"./FirstModelCreateInput\\";
export { FirstModelCreateManyInput } from \\"./FirstModelCreateManyInput\\";
export { FirstModelCreateNestedOneWithoutSecondModelsFieldInput } from \\"./FirstModelCreateNestedOneWithoutSecondModelsFieldInput\\";
export { FirstModelCreateOrConnectWithoutSecondModelsFieldInput } from \\"./FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export { FirstModelCreateWithoutSecondModelsFieldInput } from \\"./FirstModelCreateWithoutSecondModelsFieldInput\\";
export { FirstModelOrderByInput } from \\"./FirstModelOrderByInput\\";
export { FirstModelRelationFilter } from \\"./FirstModelRelationFilter\\";
export { FirstModelScalarWhereWithAggregatesInput } from \\"./FirstModelScalarWhereWithAggregatesInput\\";
export { FirstModelUncheckedCreateInput } from \\"./FirstModelUncheckedCreateInput\\";
export { FirstModelUncheckedCreateWithoutSecondModelsFieldInput } from \\"./FirstModelUncheckedCreateWithoutSecondModelsFieldInput\\";
export { FirstModelUncheckedUpdateInput } from \\"./FirstModelUncheckedUpdateInput\\";
export { FirstModelUncheckedUpdateManyInput } from \\"./FirstModelUncheckedUpdateManyInput\\";
export { FirstModelUncheckedUpdateWithoutSecondModelsFieldInput } from \\"./FirstModelUncheckedUpdateWithoutSecondModelsFieldInput\\";
export { FirstModelUpdateInput } from \\"./FirstModelUpdateInput\\";
export { FirstModelUpdateManyMutationInput } from \\"./FirstModelUpdateManyMutationInput\\";
export { FirstModelUpdateOneRequiredWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateOneRequiredWithoutSecondModelsFieldInput\\";
export { FirstModelUpdateWithoutSecondModelsFieldInput } from \\"./FirstModelUpdateWithoutSecondModelsFieldInput\\";
export { FirstModelUpsertWithoutSecondModelsFieldInput } from \\"./FirstModelUpsertWithoutSecondModelsFieldInput\\";
export { FirstModelWhereInput } from \\"./FirstModelWhereInput\\";
export { FirstModelWhereUniqueInput } from \\"./FirstModelWhereUniqueInput\\";
export { FloatFieldUpdateOperationsInput } from \\"./FloatFieldUpdateOperationsInput\\";
export { FloatFilter } from \\"./FloatFilter\\";
export { FloatWithAggregatesFilter } from \\"./FloatWithAggregatesFilter\\";
export { IntFieldUpdateOperationsInput } from \\"./IntFieldUpdateOperationsInput\\";
export { IntFilter } from \\"./IntFilter\\";
export { IntWithAggregatesFilter } from \\"./IntWithAggregatesFilter\\";
export { NestedFloatFilter } from \\"./NestedFloatFilter\\";
export { NestedFloatWithAggregatesFilter } from \\"./NestedFloatWithAggregatesFilter\\";
export { NestedIntFilter } from \\"./NestedIntFilter\\";
export { NestedIntWithAggregatesFilter } from \\"./NestedIntWithAggregatesFilter\\";
export { NestedStringFilter } from \\"./NestedStringFilter\\";
export { NestedStringWithAggregatesFilter } from \\"./NestedStringWithAggregatesFilter\\";
export { SecondModelCreateInput } from \\"./SecondModelCreateInput\\";
export { SecondModelCreateManyFirstModelFieldInput } from \\"./SecondModelCreateManyFirstModelFieldInput\\";
export { SecondModelCreateManyFirstModelFieldInputEnvelope } from \\"./SecondModelCreateManyFirstModelFieldInputEnvelope\\";
export { SecondModelCreateManyInput } from \\"./SecondModelCreateManyInput\\";
export { SecondModelCreateNestedManyWithoutFirstModelFieldInput } from \\"./SecondModelCreateNestedManyWithoutFirstModelFieldInput\\";
export { SecondModelCreateOrConnectWithoutFirstModelFieldInput } from \\"./SecondModelCreateOrConnectWithoutFirstModelFieldInput\\";
export { SecondModelCreateWithoutFirstModelFieldInput } from \\"./SecondModelCreateWithoutFirstModelFieldInput\\";
export { SecondModelListRelationFilter } from \\"./SecondModelListRelationFilter\\";
export { SecondModelOrderByInput } from \\"./SecondModelOrderByInput\\";
export { SecondModelScalarWhereInput } from \\"./SecondModelScalarWhereInput\\";
export { SecondModelScalarWhereWithAggregatesInput } from \\"./SecondModelScalarWhereWithAggregatesInput\\";
export { SecondModelUncheckedCreateInput } from \\"./SecondModelUncheckedCreateInput\\";
export { SecondModelUncheckedCreateNestedManyWithoutFirstModelFieldInput } from \\"./SecondModelUncheckedCreateNestedManyWithoutFirstModelFieldInput\\";
export { SecondModelUncheckedCreateWithoutFirstModelFieldInput } from \\"./SecondModelUncheckedCreateWithoutFirstModelFieldInput\\";
export { SecondModelUncheckedUpdateInput } from \\"./SecondModelUncheckedUpdateInput\\";
export { SecondModelUncheckedUpdateManyInput } from \\"./SecondModelUncheckedUpdateManyInput\\";
export { SecondModelUncheckedUpdateManyWithoutFirstModelFieldInput } from \\"./SecondModelUncheckedUpdateManyWithoutFirstModelFieldInput\\";
export { SecondModelUncheckedUpdateManyWithoutSecondModelsFieldInput } from \\"./SecondModelUncheckedUpdateManyWithoutSecondModelsFieldInput\\";
export { SecondModelUncheckedUpdateWithoutFirstModelFieldInput } from \\"./SecondModelUncheckedUpdateWithoutFirstModelFieldInput\\";
export { SecondModelUpdateInput } from \\"./SecondModelUpdateInput\\";
export { SecondModelUpdateManyMutationInput } from \\"./SecondModelUpdateManyMutationInput\\";
export { SecondModelUpdateManyWithWhereWithoutFirstModelFieldInput } from \\"./SecondModelUpdateManyWithWhereWithoutFirstModelFieldInput\\";
export { SecondModelUpdateManyWithoutFirstModelFieldInput } from \\"./SecondModelUpdateManyWithoutFirstModelFieldInput\\";
export { SecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput } from \\"./SecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput\\";
export { SecondModelUpdateWithoutFirstModelFieldInput } from \\"./SecondModelUpdateWithoutFirstModelFieldInput\\";
export { SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput } from \\"./SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput\\";
export { SecondModelWhereInput } from \\"./SecondModelWhereInput\\";
export { SecondModelWhereUniqueInput } from \\"./SecondModelWhereUniqueInput\\";
export { StringFieldUpdateOperationsInput } from \\"./StringFieldUpdateOperationsInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { StringWithAggregatesFilter } from \\"./StringWithAggregatesFilter\\";
"
`;
